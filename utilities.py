import xara
import xara.units.iks as units
import numpy as np
import math
import tqdm
import csv
import os

from mdof.utilities.config import extract_channels

def ReinforcedRectangle(model, id, h, b, cover, coreID, coverID, steelID, numBars, barArea, nfCoreY, nfCoreZ, nfCoverY, nfCoverZ, GJ):
    r"""
    Define a procedure which generates a rectangular reinforced concrete section
    with one layer of steel evenly distributed around the perimeter and a confined core.

                          y
                          |
                          |
                          |
                ---------------------
                |\                 /|
                | \---------------/ |
                | |               | |
                | |               | |
     z ---------| |               | |  h
                | |               | |
                | |               | |
                | /---------------\ |
                |/                 \|
                ---------------------
                          b

    Arguments
       id - tag for the section that is generated by this procedure
       h - overall height of the section (see above)
       b - overall width of the section (see above)
       cover - thickness of the cover patches
       coreID - material tag for the core patch
       coverID - material tag for the cover patches
       steelID - material tag for the reinforcing steel
       numBars - number of reinforcing bars on any given side of the section
       barArea - cross-sectional area of each reinforcing bar
       nfCoreY - number of fibers in the core patch in the y direction
       nfCoreZ - number of fibers in the core patch in the z direction
       nfCoverY - number of fibers in the cover patches with long sides in the y direction
       nfCoverZ - number of fibers in the cover patches with long sides in the z direction

    Notes
       The thickness of cover concrete is constant on all sides of the core.
       The number of bars is the same on any given side of the section.
       The reinforcing bars are all the same size.
       The number of fibers in the short direction of the cover patches is set to 1.

    Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
    Date: June 2017
    """

    # The distance from the section z-axis to the edge of the cover concrete
    # in the positive y direction
    coverY = h/2.0

    # The distance from the section y-axis to the edge of the cover concrete
    # in the positive z direction
    coverZ = b/2.0

    # Determine the corresponding values from the respective axes to the
    # edge of the core concrete
    coreY = coverY - cover
    coreZ = coverZ - cover

    # Define the fiber section
    model.section("Fiber", id, GJ=GJ)

    # Define the core patch
    model.patch("quad", coreID, nfCoreZ, nfCoreY, -coreY, coreZ, -coreY, -coreZ, coreY, -coreZ, coreY, coreZ)

    # Define the four cover patches
    model.patch("quad", coverID, 1,        nfCoverY, -coverY,  coverZ, -coreY,   coreZ,   coreY,   coreZ,   coverY,  coverZ)
    model.patch("quad", coverID, 1,        nfCoverY, -coreY,  -coreZ,  -coverY, -coverZ,  coverY, -coverZ,  coreY,  -coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,        -coverY,  coverZ, -coverY, -coverZ, -coreY,  -coreZ,  -coreY,   coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,         coreY,   coreZ,   coreY,  -coreZ,   coverY, -coverZ,  coverY,  coverZ)

    # Define the steel along constant values of y (in the z direction)
    model.layer("straight", steelID, numBars, barArea, -coreY, coreZ, -coreY, -coreZ)
    model.layer("straight", steelID, numBars, barArea,  coreY, coreZ,  coreY, -coreZ)

    # Determine the spacing for the remaining bars in the y direction
    spacingY = (2.0*coreY)/(numBars-1)

    # Avoid double counting bars
    numBars = numBars-2

    # Define remaining steel in the y direction
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY,  coreZ, (-coreY+spacingY),  coreZ)
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY, -coreZ, (-coreY+spacingY), -coreZ)


def create_frame(elastic:bool,
                       multisupport:bool,
                       verbose = False):

    # create Model in three-dimensions with 6 DOF/node
    model = xara.Model(ndm=3, ndf=6)

    # Geometry and Material Properties
        # Nodes(location)
        # Boundary conditions(nodes)
        # Elements(nodes, material properties,                             geometric transformation)
                          # non-fiber section elastic (linear)              # linear
                          # fiber section (linear elastic OR inelastic)     # PDelta
                                                                            # corotational

    # Geometry
    # ---------------

    # Set parameters for model geometry
    h  = 82.0;      # Story height 82 144
    by = 96.0;      # Bay width in Y-direction 96 240
    bx = 72.0;      # Bay width in X-direction 72 240

    # Create nodes
    #            tag    X        Y       Z 
    model.node( 1, (-bx/2.0,  by/2.0,   0.0))
    model.node( 2, ( bx/2.0,  by/2.0,   0.0))
    model.node( 3, ( bx/2.0, -by/2.0,   0.0))
    model.node( 4, (-bx/2.0, -by/2.0,   0.0))

    model.node( 5, (-bx/2.0,  by/2.0,     h))
    model.node( 6, ( bx/2.0,  by/2.0,     h))
    model.node( 7, ( bx/2.0, -by/2.0,     h))
    model.node( 8, (-bx/2.0, -by/2.0,     h))

    model.node(10, (-bx/2.0,  by/2.0, 2.0*h))
    model.node(11, ( bx/2.0,  by/2.0, 2.0*h))
    model.node(12, ( bx/2.0, -by/2.0, 2.0*h))
    model.node(13, (-bx/2.0, -by/2.0, 2.0*h))

    model.node(15, (-bx/2.0,  by/2.0, 3.0*h))
    model.node(16, ( bx/2.0,  by/2.0, 3.0*h))
    model.node(17, ( bx/2.0, -by/2.0, 3.0*h))
    model.node(18, (-bx/2.0, -by/2.0, 3.0*h))


    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(2, (1, 1, 1, 1, 1, 1))
    model.fix(3, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))


    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 4.0 # unconfined
    fpc = 5.0 # confined
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0
    if not elastic:
        # Core concrete (confined)
        #                                 tag  f'c   epsc0  f'cu  epscu
        model.uniaxialMaterial("Concrete01", 1, -fpc, -2*fpc/Ec, -3.5, -0.02)
        # Cover concrete (unconfined)
        #                                 tag  f'c   epsc0  f'cu  epscu
        model.uniaxialMaterial("Concrete01", 2, -fc, -2*fc/Ec, 0.0, -0.006)
    else:
        # Core concrete
        model.uniaxialMaterial("Elastic", 1, Ec)
        # Cover concrete
        model.uniaxialMaterial("Elastic", 2, Ec)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    if not elastic:
        #                                tag fy  E0  b
        model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)
    else:
        model.uniaxialMaterial("Elastic", 3, Es)


    # Define column elements
    # ----------------------
    # Column parameters
    h_col  = 20.0
    b_col = 20.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    ReinforcedRectangle(model, colSec,
                        h=h_col, 
                        b=b_col,
                        cover=2.5, 
                        coreID=1,
                        coverID=2,
                        steelID=3,
                        numBars=3,
                        barArea=0.79,
                        nfCoreY=8,      
                        nfCoreZ=8,      
                        nfCoverY=10,      
                        nfCoverZ=10,
                        GJ=GJ)
    # Number of column integration points (sections)
    itg_col = 1
    npts_col = 4
    model.beamIntegration("Lobatto", itg_col, colSec, npts_col)
        
    # Geometric transformation for columns
    colTransf = 1
    model.geomTransf("Linear", colTransf, (1.0, 0.0, 0.0))

    #                                tag ndI ndJ transfTag integrationTag
    model.element("forceBeamColumn",  1, ( 1,  5), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  2, ( 2,  6), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  3, ( 3,  7), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  4, ( 4,  8), transform=colTransf, section=colSec, shear=0)

    model.element("forceBeamColumn",  5, ( 5, 10), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  6, ( 6, 11), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  7, ( 7, 12), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn",  8, ( 8, 13), transform=colTransf, section=colSec, shear=0)

    model.element("forceBeamColumn",  9, (10, 15), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn", 10, (11, 16), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn", 11, (12, 17), transform=colTransf, section=colSec, shear=0)
    model.element("forceBeamColumn", 12, (13, 18), transform=colTransf, section=colSec, shear=0)

    # Define beam elements
    # --------------------

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # Second moments of area
    Ibeamzz = 1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 1.0/12.0*24.0*pow(18.0,3)
    Jbeam = Ibeamzz + Ibeamyy

    nu = 0.2
    Gb = Ec/(2 * (1 + nu))

    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, Gb, Jbeam)

    # Geometric transformation for beams
    beamTransf = 2
    model.geomTransf("Linear", beamTransf, 0.0, 0.0, 1.0)

    # Create the beam elements
    #                   tag (ndI ndJ) transfTag integrationTag
    model.element("elasticBeamColumn", 13, ( 5,  6), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 14, ( 6,  7), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 15, ( 7,  8), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 16, ( 8,  5), transform=beamTransf, section=beamSec, shear=0)

    model.element("elasticBeamColumn", 17, (10, 11), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 18, (11, 12), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 19, (12, 13), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 20, (13, 10), transform=beamTransf, section=beamSec, shear=0)

    model.element("elasticBeamColumn", 21, (15, 16), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 22, (16, 17), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 23, (17, 18), transform=beamTransf, section=beamSec, shear=0)
    model.element("elasticBeamColumn", 24, (18, 15), transform=beamTransf, section=beamSec, shear=0)

    # Lumped mass at nodes on top of columns
    # 10% of axial column capacity assuming unconfined concrete
    p = 0.1*fc*b_col*h_col
    m = p/units.gravity
    #         tag   MX MY MZ   RX   RY   RZ
    model.mass( 5, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 6, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 7, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 8, (m, m, m, 0.0, 0.0, 0.0))

    model.mass( 10, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 11, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 12, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 13, (m, m, m, 0.0, 0.0, 0.0))

    model.mass( 15, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 16, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 17, (m, m, m, 0.0, 0.0, 0.0))
    model.mass( 18, (m, m, m, 0.0, 0.0, 0.0))

    # set rayleigh damping factors
    model.rayleigh(0.0319, 0.0, 0.0125, 0.0)

    return model


def apply_load_frame(model, inputx=None, inputy=None, dt=None):
    """
    Add dynamic loads to frame model
    """
    if np.all(inputx is None) or np.all(inputy is None) or dt is None:
        raise ValueError("Missing inputx, inputy, or dt. Exiting.")
    
    # Define earthquake excitation
    # ----------------------------
    # Set up the acceleration records for fault normal (x, dof 1) and fault parallel (y, dof 2)
    model.timeSeries("Path", 2, values=inputx.tolist(), dt=dt, factor=1.0)
    model.timeSeries("Path", 3, values=inputy.tolist(), dt=dt, factor=1.0)

    # Define the excitation using the given ground motion records
    #                         tag dir         accel series args
    model.pattern("UniformExcitation", 2, 1, accel=2)
    model.pattern("UniformExcitation", 3, 2, accel=3)

    return model


def get_inputs(i, events, input_channels, scale=1):
    event = events[i]
    inputs, dt = extract_channels(event, input_channels)
    inputs = scale*inputs
    return inputs, dt


def get_material_response(model, element, sec_tag, y, z):
    try:
        strain =  model.eleResponse(element, "section", sec_tag, "fiber", y, z, "strain")
        stress =  model.eleResponse(element, "section", sec_tag, "fiber", y, z, "stress")
        return strain, stress
    except Exception as e:
        print(e)
        return None

# CHECK NG: consolidated new analyze here
def analyze(model, nt, dt, 
            output_nodes=[5,10,15],
            output_elements=[1,5,9],
            n_modes=3,
            yFiber=9.0,
            zFiber=0.0,
            verbose=False,
            ):

    # ----------------------------
    # 1. Configure the analysis
    # ----------------------------

    # create the system of equation
    model.system("BandGen")

    # create the DOF numberer
    model.numberer("RCM")

    # create the constraint handler
    model.constraints("Transformation")

    # Configure the analysis such that iterations are performed until either:
    # 1. the energy increment is less than 1.0e-14 (success)
    # 2. the number of iterations surpasses 20 (failure)
    #model.test("EnergyIncr", 1.0e-14, 40)
    model.test("NormDispIncr", 1.0e-6, 40)

    # Perform iterations with the Newton-Raphson algorithm
    #model.algorithm("Newton")
    model.algorithm("NewtonLineSearch")

    # define the integration scheme, the Newmark with gamma=0.5 and beta=0.25
    model.integrator("Newmark", 0.5, 0.25)

    # Define the analysis
    model.analysis("Transient")

    # -----------------------
    # 3. Perform the analysis
    # -----------------------

    # record once at time 0
    displacements = {
        node: [model.nodeDisp(node)] for node in output_nodes
    }
    accelerations = {
        node: [model.nodeAccel(node)] for node in output_nodes
    }
    strains = {
        element: [get_material_response(model, element, 1, yFiber, zFiber)[0]] for element in output_elements
    }
    stresses = {
        element: [get_material_response(model, element, 1, yFiber, zFiber)[1]] for element in output_elements
    }

    # get modes
    lambdas = model.eigen(n_modes, "fullGenLapack")  
    omega = np.sqrt(np.abs(lambdas))
    freqs_before = omega/(2*np.pi) 

    # Perform nt analysis steps with a time step of dt
    if verbose:
        print(f"Analysis Progress ({nt} timesteps)")
        timesteps = tqdm.tqdm(range(nt))
    else:
        timesteps = range(nt)
    for i in timesteps:
        status = model.analyze(1, dt) 
        if status != 0:
            raise RuntimeError(f"analysis failed at time {model.getTime()}")
        
        # Save displacements at the current time
        for node in output_nodes:
            displacements[node].append(model.nodeDisp(node))
            accelerations[node].append(model.nodeAccel(node))
        
        for element in output_elements:
            strains[element].append(get_material_response(model, element, 1, yFiber, zFiber)[0])
            stresses[element].append(get_material_response(model, element, 1, yFiber, zFiber)[1])

    lambdas_after = model.eigen(n_modes, "fullGenLapack") 
    omega_after = np.sqrt(np.abs(lambdas_after))   
    freqs_after = omega_after/(2*np.pi)
           
    return displacements, accelerations, stresses, strains, freqs_before, freqs_after


def write_freq_csv(event_id,
                   freqs_before,
                   freqs_after,
                   freq_csv_path="natural_frequencies.csv"):
    
    n_modes = len(freqs_before)
    
    file_exists = os.path.exists(freq_csv_path)

    with open(freq_csv_path, "a", newline="") as f:
        writer = csv.writer(f)
        if not file_exists:
            header = ["event_id"]
            header += [f"f{i+1}_before_Hz" for i in range(n_modes)] #Hz
            header += [f"f{i+1}_after_Hz" for i in range(n_modes)]
            writer.writerow(header)
        row = [event_id] + list(freqs_before) + list(freqs_after)
        writer.writerow(row)


# CHECK NG: consolidated both get_node_displacements and get_node_accelerations; removed dt argument
def get_node_outputs(outputs,
                #nodes=[5,10,15], # building (3 story frame)
                nodes=[2,3,5], # bridge
                ):
    """
    outputs, e.g. displacements or accelerations:
      { node_id: [ [u1,u2,u3,u4,u5,u6], ... ] }
    Returns outputs: ndarray, shape=(n_nodes*2, nt), row order:
      [Node1 X, Node1 Y, Node2 X, Node2 Y, ...]
    """
    
    rows = []
    for node in nodes:
        arr = np.array(outputs[node])  # shape (nt+1, 6)
        rows.append(arr[:, 0])  # X output 
        rows.append(arr[:, 1])  # Y output

    outputs = np.vstack(rows)
    return outputs     # shape (2*n_nodes, nt)
