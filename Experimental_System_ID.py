# ===----------------------------------------------------------------------===//
# 
#         OpenSees - Open System for Earthquake Engineering Simulation    
#                Structural Artificial Intelligence Laboratory
# 
# ===----------------------------------------------------------------------===//
#
# 3 Story One-by-One Bay Frame
# ----------------------------
#  Reinforced concrete one-bay, three-story frame
#  Distributed vertical load on girder
# 
# Example Objectives
# ------------------
#  - 3D building with rigid diaphragms
#  - Nonlinear beam-column elements
#  - Gravity load analysis followed by transient analysis


#import opensees.openseespy as ops
import xara as ops
#import openseespy.opensees as ops
import xara.units.iks as units
import math

#——————new import——————
from pathlib import Path
import quakeio
import numpy as np
from mdof.utilities.config import extract_channels
import json
import csv
import os
import numpy as np
import matplotlib.pyplot as plt
from mdof.simulate import simulate
from mdof import sysid
from mdof.realize import n4sid
from mdof.utilities.printing import plot_pred
from mdof.validation import stabilize_discrete
from mdof import modes
from mdof.utilities.config import Config

from mdof.utilities.testing import intensity_bounds, truncate_by_bounds

#针对lacy 字体显示白色了话需要在左边打开文件夹
import cvxpy as cp #print(cvxpy.__version__)用这个可以检查版本号
import dccp

import pickle


LOAD_EVENTS = False

def ReinforcedRectangle(model, id, h, b, cover, coreID, coverID, steelID, numBars, barArea, nfCoreY, nfCoreZ, nfCoverY, nfCoverZ, GJ):
    r"""
    Define a procedure which generates a rectangular reinforced concrete section
    with one layer of steel evenly distributed around the perimeter and a confined core.

                          y
                          |
                          |
                          |
                ---------------------
                |\                 /|
                | \---------------/ |
                | |               | |
                | |               | |
     z ---------| |               | |  h
                | |               | |
                | |               | |
                | /---------------\ |
                |/                 \|
                ---------------------
                          b

    Arguments
       id - tag for the section that is generated by this procedure
       h - overall height of the section (see above)
       b - overall width of the section (see above)
       cover - thickness of the cover patches
       coreID - material tag for the core patch
       coverID - material tag for the cover patches
       steelID - material tag for the reinforcing steel
       numBars - number of reinforcing bars on any given side of the section
       barArea - cross-sectional area of each reinforcing bar
       nfCoreY - number of fibers in the core patch in the y direction
       nfCoreZ - number of fibers in the core patch in the z direction
       nfCoverY - number of fibers in the cover patches with long sides in the y direction
       nfCoverZ - number of fibers in the cover patches with long sides in the z direction

    Notes
       The thickness of cover concrete is constant on all sides of the core.
       The number of bars is the same on any given side of the section.
       The reinforcing bars are all the same size.
       The number of fibers in the short direction of the cover patches is set to 1.

    Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
    Date: June 2017
    """

    # The distance from the section z-axis to the edge of the cover concrete
    # in the positive y direction
    coverY = h/2.0

    # The distance from the section y-axis to the edge of the cover concrete
    # in the positive z direction
    coverZ = b/2.0

    # Determine the corresponding values from the respective axes to the
    # edge of the core concrete
    coreY = coverY - cover
    coreZ = coverZ - cover

    # Define the fiber section
    model.section("Fiber", id, GJ=GJ)

    # Define the core patch
    model.patch("quad", coreID, nfCoreZ, nfCoreY, -coreY, coreZ, -coreY, -coreZ, coreY, -coreZ, coreY, coreZ)

    # Define the four cover patches
    model.patch("quad", coverID, 1,        nfCoverY, -coverY,  coverZ, -coreY,   coreZ,   coreY,   coreZ,   coverY,  coverZ)
    model.patch("quad", coverID, 1,        nfCoverY, -coreY,  -coreZ,  -coverY, -coverZ,  coverY, -coverZ,  coreY,  -coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,        -coverY,  coverZ, -coverY, -coverZ, -coreY,  -coreZ,  -coreY,   coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,         coreY,   coreZ,   coreY,  -coreZ,   coverY, -coverZ,  coverY,  coverZ)

    # Define the steel along constant values of y (in the z direction)
    model.layer("straight", steelID, numBars, barArea, -coreY, coreZ, -coreY, -coreZ)
    model.layer("straight", steelID, numBars, barArea,  coreY, coreZ,  coreY, -coreZ)

    # Determine the spacing for the remaining bars in the y direction
    spacingY = (2.0*coreY)/(numBars-1)

    # Avoid double counting bars
    numBars = numBars-2

    # Define remaining steel in the y direction
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY,  coreZ, (-coreY+spacingY),  coreZ)
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY, -coreZ, (-coreY+spacingY), -coreZ)



def create_model(eleType=None, inputx=None, inputy=None):

    if eleType is None:
        eleType = "forceBeamColumn"

    # create Model in three-dimensions with 6 DOF/node
    model = ops.Model(ndm=3, ndf=6)

    # Geometry
    # ---------------

    # Set parameters for model geometry
    h  = 144.0;      # Story height
    by = 240.0;      # Bay width in Y-direction
    bx = 240.0;      # Bay width in X-direction

    # Create nodes
    #            tag    X        Y       Z 
    model.node( 1, (-bx/2.0,  by/2.0,   0.0))
    model.node( 2, ( bx/2.0,  by/2.0,   0.0))
    model.node( 3, ( bx/2.0, -by/2.0,   0.0))
    model.node( 4, (-bx/2.0, -by/2.0,   0.0))

    model.node( 5, (-bx/2.0,  by/2.0,     h))
    model.node( 6, ( bx/2.0,  by/2.0,     h))
    model.node( 7, ( bx/2.0, -by/2.0,     h))
    model.node( 8, (-bx/2.0, -by/2.0,     h))

    model.node(10, (-bx/2.0,  by/2.0, 2.0*h))
    model.node(11, ( bx/2.0,  by/2.0, 2.0*h))
    model.node(12, ( bx/2.0, -by/2.0, 2.0*h))
    model.node(13, (-bx/2.0, -by/2.0, 2.0*h))

    model.node(15, (-bx/2.0,  by/2.0, 3.0*h))
    model.node(16, ( bx/2.0,  by/2.0, 3.0*h))
    model.node(17, ( bx/2.0, -by/2.0, 3.0*h))
    model.node(18, (-bx/2.0, -by/2.0, 3.0*h))

    # Retained nodes for rigid diaphragm
    #        tag    ( X    Y    Z   )
    model.node( 9,  (0.0, 0.0,     h))
    model.node(14,  (0.0, 0.0, 2.0*h))
    model.node(19,  (0.0, 0.0, 3.0*h))

    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(2, (1, 1, 1, 1, 1, 1))
    model.fix(3, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))

    # Define rigid diaphragm multi-point constraints
    #              normalDir retained constrained
    model.rigidDiaphragm(3,  9,  5,  6,  7,  8)
    model.rigidDiaphragm(3, 14, 10, 11, 12, 13)
    model.rigidDiaphragm(3, 19, 15, 16, 17, 18)

    # Constraints for rigid diaphragm retained nodes
    #        tag  (DX DY DZ RX RY RZ)
    model.fix( 9, ( 0, 0, 1, 1, 1, 0))
    model.fix(14, ( 0, 0, 1, 1, 1, 0))
    model.fix(19, ( 0, 0, 1, 1, 1, 0))

    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 4.0
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0

    # Core concrete (confined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 1, -5.0, -0.005, -3.5, -0.02)

    # Cover concrete (unconfined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 2, -fc, -0.002, 0.0, -0.006)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    #                                tag fy  E0  b
    model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)

    # Column parameters
    h  = 18.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    # Call the RCsection procedure to generate the column section
    #                              id  h  b cover core cover steel nBars barArea nfCoreY nfCoreZ nfCoverY nfCoverZ GJ
    ReinforcedRectangle(model, colSec, h, h, 2.5, 1,    2,    3,    3,   0.79,     8,      8,      10,      10,   GJ)

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # "Cracked" second moments of area
    Ibeamzz = 0.5*1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 0.5*1.0/12.0*24.0*pow(18.0,3)

    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, GJ, 1.0)

    # Define column elements
    # ----------------------
    PDelta = "OFF"
    #PDelta = "ON"

    # Geometric transformation for columns
    if (PDelta == "OFF"):
       model.geomTransf("Linear", 1, (1.0, 0.0, 0.0))
    else:
       model.geomTransf("PDelta", 1, (1.0, 0.0, 0.0))

    # Number of column integration points (sections)
    np = 4
    itg = 1
    model.beamIntegration("Lobatto", itg, colSec, np)


    #                   tag ndI ndJ transfTag integrationTag
    model.element(eleType,  1, ( 1,  5), 1, itg)
    model.element(eleType,  2, ( 2,  6), 1, itg)
    model.element(eleType,  3, ( 3,  7), 1, itg)
    model.element(eleType,  4, ( 4,  8), 1, itg)

    model.element(eleType,  5, ( 5, 10), 1, itg)
    model.element(eleType,  6, ( 6, 11), 1, itg)
    model.element(eleType,  7, ( 7, 12), 1, itg)
    model.element(eleType,  8, ( 8, 13), 1, itg)

    model.element(eleType,  9, (10, 15), 1, itg)
    model.element(eleType, 10, (11, 16), 1, itg)
    model.element(eleType, 11, (12, 17), 1, itg)
    model.element(eleType, 12, (13, 18), 1, itg)

    # Define beam elements
    # --------------------

    # Geometric transformation for beams
    model.geomTransf("Linear", 2, 1.0, 1.0, 0.0)

    # Number of beam integration points (sections)
    np = 3
    model.beamIntegration("Lobatto", beamSec, beamSec, np)

    # Create the beam elements
    eleType = "forceBeamColumn"
    #                   tag (ndI ndJ) transfTag integrationTag
    model.element(eleType, 13, ( 5,  6), 2, beamSec)
    model.element(eleType, 14, ( 6,  7), 2, beamSec)
    model.element(eleType, 15, ( 7,  8), 2, beamSec)
    model.element(eleType, 16, ( 8,  5), 2, beamSec)

    model.element(eleType, 17, (10, 11), 2, beamSec)
    model.element(eleType, 18, (11, 12), 2, beamSec)
    model.element(eleType, 19, (12, 13), 2, beamSec)
    model.element(eleType, 20, (13, 10), 2, beamSec)

    model.element(eleType, 21, (15, 16), 2, beamSec)
    model.element(eleType, 22, (16, 17), 2, beamSec)
    model.element(eleType, 23, (17, 18), 2, beamSec)
    model.element(eleType, 24, (18, 15), 2, beamSec)

    # Define gravity loads
    # --------------------
    # Gravity load applied at each corner node
    # 10% of column capacity
    p = 0.1*fc*h*h

    # Mass lumped at retained nodes
    m = (4.0*p)/units.gravity

    # Rotary inertia of floor about retained node
    i = m*(bx*bx + by*by)/12.0

    # Set mass at the retained nodes
    #         tag   MX MY MZ   RX   RY   RZ
    model.mass( 9, (m, m, 0.0, 0.0, 0.0, i))
    model.mass(14, (m, m, 0.0, 0.0, 0.0, i))
    model.mass(19, (m, m, 0.0, 0.0, 0.0, i))

    # Define gravity loads
    # create a Plain load pattern with Constant scaling
    model.pattern("Plain", 1, "Constant")

    for i in [5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18]:
        model.load(i, (0.0, 0.0, -p, 0.0, 0.0, 0.0), pattern=1)

    # set rayleigh damping factors
    model.rayleigh(0.0, 0.0, 0.0, 0.0018)

    # Define earthquake excitation
    # ----------------------------
    dt = 0.02
    # Set up the acceleration records for Tabas fault normal and fault parallel
    if inputx is None and inputy is None:
        model.timeSeries("Path", 2, filePath="tabasFN.txt", dt=dt, factor=units.gravity)
        model.timeSeries("Path", 3, filePath="tabasFP.txt", dt=dt, factor=units.gravity)
    else:
        model.timeSeries("Path", 2, values=inputx, dt=dt, factor=1.0)
        model.timeSeries("Path", 3, values=inputy, dt=dt, factor=1.0)

    # Define the excitation using the Tabas ground motion records
    #                         tag dir         accel series args
    model.pattern("UniformExcitation", 2, 1, accel=2)
    model.pattern("UniformExcitation", 3, 2, accel=3)

    return model


def get_inputs(i, events, input_channels, scale=1):
    event = events[i]
    inputs, dt = extract_channels(event, input_channels)
    inputs = scale*inputs
    return inputs, dt


def save_event_io(i, inputs, outputs, dt, out_dir="event_data"):
    os.makedirs(out_dir, exist_ok=True)
    nt = inputs.shape[1]
    time = np.arange(nt) * dt
    
    # —— Save as CSV (readable) —— 
    csv_in = os.path.join(out_dir, f"event_{i+1}_inputs.csv")
    with open(csv_in, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["time","acc_X","acc_Y"])
        for t, x, y in zip(time, inputs[0], inputs[1]):
            writer.writerow([t, x, y])
    
    csv_out = os.path.join(out_dir, f"event_{i+1}_outputs.csv")
    with open(csv_out, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["time","1F_X","1F_Y","2F_X","2F_Y","3F_X","3F_Y"])
        for idx in range(nt):
            row = [time[idx]] + [outputs[r,idx] for r in range(6)]
            writer.writerow(row)
    

def analyze(model, output_nodes, nt, dt):
    # ----------------------------
    # 1. Configure the analysis
    # ----------------------------

    # create the system of equation
    model.system("UmfPack")

    # create the DOF numberer
    model.numberer("Plain")

    # create the constraint handler
    model.constraints("Transformation")

    # Configure the analysis such that iterations are performed until either:
    # 1. the energy increment is less than 1.0e-8 (success)
    # 2. the number of iterations surpasses 20 (failure)
    model.test("EnergyIncr", 1.0e-8, 20)

    # Perform iterations with the Newton-Raphson algorithm
    model.algorithm("Newton")

    # define the integration scheme, the Newmark with gamma=0.5 and beta=0.25
    model.integrator("Newmark", 0.5, 0.25)

    # Define the analysis
    model.analysis("Transient")

    # ------------------------------
    # 2. Define quantities to record
    # ------------------------------

    # Record DOF 1 and 2 displacements at nodes 9, 14, and 19
    model.recorder("Node", "disp", "-file", "Node51.out", "-time", "-node", *output_nodes, "-dof", 1, 2) #原来是9，14，19改成*output_nodes


    # -----------------------
    # 3. Perform the analysis
    # -----------------------

    # record once at time 0
    displacements = {
        node: [model.nodeDisp(node)] for node in output_nodes
    }

    # Perform 2000 analysis steps with a time step of 0.01
    for i in range(nt):
        status = model.analyze(1, dt) #dt控制时间间隔原来是0.01
        if status != 0:
            raise RuntimeError(f"analysis failed at time {model.getTime()}")

        # Save displacements at the current time
        for node in output_nodes:
            displacements[node].append(model.nodeDisp(node))
           
    return displacements

def get_outputs(displacements):
    """
    displacements: { node_id: [ [u1,u2,u3,u4,u5,u6], ... ] }
    Returns outputs: ndarray, shape=(6, nt), row order:
      [1F X, 1F Y, 2F X, 2F Y, 3F X, 3F Y]
    """
    floors = [9, 14, 19]
    rows = []
    for node in floors:
        arr = np.array(displacements[node])  # shape (nt+1, 6)
        rows.append(arr[:, 0])  # X displacement 
        rows.append(arr[:, 1])  # Y displacement
    outputs = np.vstack(rows)
    return outputs     # shape (6, nt+1)

def stabilize_with_lmi(A_hat, epsilon=1e-10, solver='CVXOPT'):
    """
    Only the matrix A_s obtained from algorithms such as SRIM is stabilized by imposing a Lyapunov LMI constraint to obtain a stable A. 
    The matrices B_s, C_s, and D_s are directly used as output. 
    This corresponds to Section II of Lacy & Bernstein (2003).
    The solver can be set to either SCS or CVXOPT, and epsilon can be chosen starting from 1e-8.
    """
    n = A_hat.shape[0]

    # #Define only Q and P as variables
    P = cp.Variable((n, n), PSD=True)
    Q = cp.Variable((n, n))

    # —— Objective function ——— (Equation 2.17)
    objective = cp.Minimize(cp.norm(A_hat @ P - Q, "fro")**2)

    # —— Lyapunov LMI constraint ——— (Equation 2.18)
    M = cp.bmat([
        [P - epsilon * np.eye(n), Q],
        [Q.T, P]
    ])
    constraints = [M >> 0]

    # —— Solve the optimization problem —— 
    prob = cp.Problem(objective, constraints)
    prob.solve(solver=solver)

    A_stable = Q.value @ np.linalg.inv(P.value)
    return A_stable

if __name__ == "__main__":
    print(cp.__version__)
    print(dccp.__version__)

    base_out = "output_srim_window_channel0103_option_lmi-new-3"  #rename:output_okid-era_zoomin_channel0317_original_A_option按照这个顺序来写
    pred_dir = os.path.join(base_out, "predictions")
    data_dir = os.path.join(base_out, "event_data")
    os.makedirs(pred_dir, exist_ok=True)
    os.makedirs(data_dir, exist_ok=True)

    # —— First load channel configuration ——  
    station_id = 'CE89324'

    # **choose channel
    input_channels = [1,3]

    if LOAD_EVENTS:
        events = sorted([
            print(file) or quakeio.read(file, exclusions=["*filter*"])
            for file in list(Path(f"../uploads/CE89324/").glob("????????*.[zZ][iI][pP]"))
        ], key=lambda event: abs(event["peak_accel"]))
        with open("events.pkl","wb") as f:
            pickle.dump(events,f)
    else:
        with open("events.pkl","rb") as f:
            events = pickle.load(f)

    try:
        plt.style.use("typewriter")
    except:
        pass

    do_plot = True   # **Control whether to plot a heatmap
    # Preallocate an error matrix (channels × events) 
    num_events   = len(events)
    num_channels = 6    # 1F X/Y, 2F X/Y, 3F X/Y
    error_matrix = np.zeros((num_channels, num_events))

    for i in range(21):
        # TODO: if earthquake is too strong, change scale to smaller. try 0.3
        inputs, dt = get_inputs(i, events=events, input_channels=input_channels, scale=1)

        print(f"event {i+1}inputs shape: {inputs.shape}, dt = {dt}")
        print(" channel 1 first 5 sample: ", inputs[0, :5])
        print(" channel 3 first 5 sample: ", inputs[1, :5])


        model = create_model("forceBeamColumn",
                             inputx=inputs[0],
                             inputy=inputs[1])
        
        nt = inputs.shape[1] # The second axis represents the number of sample points per channel
        disp = analyze(model, output_nodes=[9, 14, 19], nt=nt, dt=dt)
        outputs = get_outputs(disp)     # shape (6, nt)
        outputs = outputs[:, 1:]
        inputs = inputs[:, :nt]
        time = np.arange(nt) * dt

        i_val = 2 #when method choosed as n4sid or deterministic
        j_val = 80

        # option
        n = 6
        options = Config(
            m           = 500,
            horizon     = 190,
            nc          = 190,
            order       = 2*n,
            period_band = (0.1,0.6),
            damping     = 0.06,
            pseudo      = True,
            outlook     = 190,
            threads     = 8,
            chunk       = 200
        )

        # **Choose whether to stabilize matrix A and whether to use the LMI method
        sys_s  = sysid(inputs,  outputs, method='srim', **options) #method= srim, okid-era, okid-era-dc, deterministic , options = options , **option
        A_s, B_s, C_s, D_s, *rest = sys_s
        A_s = stabilize_discrete(A_s)
        A_stable = stabilize_with_lmi(A_s, epsilon=1e-6, solver='CVXOPT')
        
        eigvals_A_s = np.linalg.eigvals(A_s)
        eigvals_A_stable = np.linalg.eigvals(A_stable)
        print("A_s Eigenvalues:", eigvals_A_s)
        print("A_stable Eigenvalues:", eigvals_A_stable)

        pred_s = simulate((A_stable, B_s, C_s, D_s),  inputs) #A_s, B_s, C_s, D_s
        print("C_s:", C_s.shape)
        
        windowed_plot = True # **True or False
        
        # Choose whether to do windowplot
        if windowed_plot:
            # Use the first response channel to calculate the time bounds of the main energy interval 
            # (from the 0.01 to 0.99 quantiles)
            bounds = intensity_bounds(outputs[0], lb=0.01, ub=0.99)
            outputs_trunc          = truncate_by_bounds(outputs, bounds)
            pred_s_trunc           = truncate_by_bounds(pred_s,   bounds)
            time_trunc             = time[bounds[0]:bounds[1]]
        else:
            outputs_trunc          = outputs
            pred_s_trunc           = pred_s
            time_trunc             = time
        
        # Compute and store the L2 error for the windowed segment
        for ch in range(num_channels):
            num = np.linalg.norm(outputs_trunc[ch] - pred_s_trunc[ch])
            den = np.linalg.norm(outputs_trunc[ch])
            pred_norm = np.linalg.norm(pred_s_trunc[ch])
            print(f"Event {i+1} Ch {ch}: ‖pred‖={pred_norm:.3e}, ‖diff‖={num:.3e}, ‖true‖={den:.3e}, ratio={num/den:.3f}")
            error_matrix[ch, i] = num

        # Save data
        np.savez(
            os.path.join(data_dir, f"event_{i+1}.npz"),
            time=time, inputs=inputs, outputs=outputs
        )
        # (Can add CSV saving as needed, like previous examples)

        # Plot 2 figures and save
        fig, axs = plt.subplots(1, 2, figsize=(12,4), constrained_layout=True)
        floors = [0,1,2]

        # SRIM — X direction on the left
        ax = axs[0]
        for f in floors:
            ax.plot(time_trunc,
                    outputs_trunc[2*f],  
                    '--', label=f"True Fl{f+1} X")
            ax.plot(time_trunc,           
                    pred_s_trunc[2*f],  
                    label=f"SRIM Fl{f+1} X")
            
        ax.set(title="SRIM — X direction", xlabel="Time (s)", ylabel="Disp") #SRIM N4SID Deterministic okid-era
        ax.legend()

        # SRIM — Y direction on the right
        ax = axs[1]
        for f in floors:
            ax.plot(time_trunc,
                    outputs_trunc[2*f+1],
                    '--', label=f"True Fl{f+1} Y")
            ax.plot(time_trunc,
                    pred_s_trunc[2*f+1],
                    label=f"SRIM Fl{f+1} Y")
            
        ax.set(title="SRIM — Y direction", xlabel="Time (s)", ylabel="Disp")
        ax.legend()

        plt.suptitle(f"Event {i+1} ")
        plt.savefig(os.path.join(pred_dir, f"event_{i+1}_sysid.png"), dpi=300)
        plt.close(fig)

    # heatmap plot
    if do_plot:
        
        fig, ax = plt.subplots(figsize=(12,6), constrained_layout=True)
        im = ax.imshow(error_matrix,
                    vmin=0, vmax=error_matrix.max(),
                    aspect='auto',
                    origin='lower',
                    cmap='viridis')
        cbar = fig.colorbar(im, ax=ax, extend='max')
        cbar.set_label("Absolute error norm", fontsize=14) #"Absolute error norm"

        ax.set_xlabel("Event index", fontsize=14)
        ax.set_ylabel("Channel", fontsize=14)
        ax.set_xticks(np.arange(num_events))
        ax.set_xticklabels(np.arange(1, num_events+1), rotation=45, fontsize=12)
        channel_labels = ['1F X','1F Y','2F X','2F Y','3F X','3F Y']
        ax.set_yticks(np.arange(num_channels))
        ax.set_yticklabels(channel_labels, fontsize=12)

        ax.set_title("Error heatmap (windowed part)", fontsize=16) 
        for ch in range(num_channels):
            for ev in range(num_events):
                val = error_matrix[ch, ev]
                if val <= 9999:
                    color = 'black' if val > error_matrix.max()/2 else 'white'
                    ax.text(
                        ev, ch,
                        f"{val:.2f}",
                        ha='center', va='center',
                        color=color,
                        fontsize=6
                    )

        heatmap_path = os.path.join(pred_dir, "error_heatmap.png")
        plt.savefig(heatmap_path, dpi=300)
        plt.close(fig)
        print(f"Error heatmap saved to {heatmap_path}")

    print(f"All outputs have been saved to: {os.path.abspath(base_out)}")

