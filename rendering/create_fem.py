import xara
import xara.units.iks as units
import math
import warnings

def ReinforcedRectangle(model, id, h, b, cover, coreID, coverID, steelID, numBars, barArea, nfCoreY, nfCoreZ, nfCoverY, nfCoverZ, GJ):
    r"""
    Define a procedure which generates a rectangular reinforced concrete section
    with one layer of steel evenly distributed around the perimeter and a confined core.

                          y
                          |
                          |
                          |
                ---------------------
                |\                 /|
                | \---------------/ |
                | |               | |
                | |               | |
     z ---------| |               | |  h
                | |               | |
                | |               | |
                | /---------------\ |
                |/                 \|
                ---------------------
                          b

    Arguments
       id - tag for the section that is generated by this procedure
       h - overall height of the section (see above)
       b - overall width of the section (see above)
       cover - thickness of the cover patches
       coreID - material tag for the core patch
       coverID - material tag for the cover patches
       steelID - material tag for the reinforcing steel
       numBars - number of reinforcing bars on any given side of the section
       barArea - cross-sectional area of each reinforcing bar
       nfCoreY - number of fibers in the core patch in the y direction
       nfCoreZ - number of fibers in the core patch in the z direction
       nfCoverY - number of fibers in the cover patches with long sides in the y direction
       nfCoverZ - number of fibers in the cover patches with long sides in the z direction

    Notes
       The thickness of cover concrete is constant on all sides of the core.
       The number of bars is the same on any given side of the section.
       The reinforcing bars are all the same size.
       The number of fibers in the short direction of the cover patches is set to 1.

    Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
    Date: June 2017
    """

    # The distance from the section z-axis to the edge of the cover concrete
    # in the positive y direction
    coverY = h/2.0

    # The distance from the section y-axis to the edge of the cover concrete
    # in the positive z direction
    coverZ = b/2.0

    # Determine the corresponding values from the respective axes to the
    # edge of the core concrete
    coreY = coverY - cover
    coreZ = coverZ - cover

    # Define the fiber section
    model.section("Fiber", id, GJ=GJ)

    # Define the core patch
    model.patch("quad", coreID, nfCoreZ, nfCoreY, -coreY, coreZ, -coreY, -coreZ, coreY, -coreZ, coreY, coreZ)

    # Define the four cover patches
    model.patch("quad", coverID, 1,        nfCoverY, -coverY,  coverZ, -coreY,   coreZ,   coreY,   coreZ,   coverY,  coverZ)
    model.patch("quad", coverID, 1,        nfCoverY, -coreY,  -coreZ,  -coverY, -coverZ,  coverY, -coverZ,  coreY,  -coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,        -coverY,  coverZ, -coverY, -coverZ, -coreY,  -coreZ,  -coreY,   coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,         coreY,   coreZ,   coreY,  -coreZ,   coverY, -coverZ,  coverY,  coverZ)

    # Define the steel along constant values of y (in the z direction)
    model.layer("straight", steelID, numBars, barArea, -coreY, coreZ, -coreY, -coreZ)
    model.layer("straight", steelID, numBars, barArea,  coreY, coreZ,  coreY, -coreZ)

    # Determine the spacing for the remaining bars in the y direction
    spacingY = (2.0*coreY)/(numBars-1)

    # Avoid double counting bars
    numBars = numBars-2

    # Define remaining steel in the y direction
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY,  coreZ, (-coreY+spacingY),  coreZ)
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY, -coreZ, (-coreY+spacingY), -coreZ)

def create_frame_model(column=None, girder="forceBeamColumn"):

    if column is None:
        column = "forceBeamColumn"

    # create Model in three-dimensions with 6 DOF/node
    model = xara.Model(ndm=3, ndf=6)

    # Geometry and Material Properties
        # Nodes(location)
        # Boundary conditions(nodes)
        # Elements(nodes, material properties,                             geometric transformation)
                          # non-fiber section elastic (linear)              # linear
                          # fiber section (linear elastic OR inelastic)     # PDelta
                                                                            # corotational

    # Geometry
    # ---------------

    # Set parameters for model geometry
    h  = 144.0;      # Story height
    by = 240.0;      # Bay width in Y-direction
    bx = 240.0;      # Bay width in X-direction

    # Create nodes
    #            tag    X        Y       Z 
    model.node( 1, (-bx/2.0,  by/2.0,   0.0))
    model.node( 2, ( bx/2.0,  by/2.0,   0.0))
    model.node( 3, ( bx/2.0, -by/2.0,   0.0))
    model.node( 4, (-bx/2.0, -by/2.0,   0.0))

    model.node( 5, (-bx/2.0,  by/2.0,     h))
    model.node( 6, ( bx/2.0,  by/2.0,     h))
    model.node( 7, ( bx/2.0, -by/2.0,     h))
    model.node( 8, (-bx/2.0, -by/2.0,     h))

    model.node(10, (-bx/2.0,  by/2.0, 2.0*h))
    model.node(11, ( bx/2.0,  by/2.0, 2.0*h))
    model.node(12, ( bx/2.0, -by/2.0, 2.0*h))
    model.node(13, (-bx/2.0, -by/2.0, 2.0*h))

    model.node(15, (-bx/2.0,  by/2.0, 3.0*h))
    model.node(16, ( bx/2.0,  by/2.0, 3.0*h))
    model.node(17, ( bx/2.0, -by/2.0, 3.0*h))
    model.node(18, (-bx/2.0, -by/2.0, 3.0*h))


    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(2, (1, 1, 1, 1, 1, 1))
    model.fix(3, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))

    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 4.0
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0

    # Core concrete (confined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 1, -5.0, -0.005, -3.5, -0.02)

    # Cover concrete (unconfined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 2, -fc, -0.002, 0.0, -0.006)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    #                                tag fy  E0  b
    model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)

    # Column parameters
    h_col  = 24.0
    w_col = 24.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    # # Call the RCsection procedure to generate the column section
    # #                              id  h  b cover core cover steel nBars barArea nfCoreY nfCoreZ nfCoverY nfCoverZ GJ
    # ReinforcedRectangle(model, colSec, h, h, 2.5, 1,    2,    3,    3,   0.79,     8,      8,      10,      10,   GJ)
    # Define material properties for elastic columns
    # Using column depth of 24 and width of 18
    Acol = h_col*w_col
    # "Cracked" second moments of area
    Icolzz = 0.5*1.0/12.0*h_col*pow(w_col,3)
    Icolyy = 0.5*1.0/12.0*h_col*pow(w_col,3)
    # Define elastic section for columns
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", colSec, Ec, Acol, Icolzz, Icolyy, GJ, 1.0)

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # "Cracked" second moments of area
    Ibeamzz = 0.5*1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 0.5*1.0/12.0*24.0*pow(18.0,3)

    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, GJ, 1.0)

    # Define column elements
    # ----------------------
    # Geometric transformation for columns
    colTransf = 1
    model.geomTransf("Linear", colTransf, (1.0, 0.0, 0.0))

    # Number of column integration points (sections)
    itg_col = 1
    npts_col = 4
    model.beamIntegration("Lobatto", itg_col, colSec, npts_col)


    #                   tag ndI ndJ transfTag integrationTag
    model.element(column,  1, ( 1,  5), transform=colTransf, section=colSec, shear=0)
    model.element(column,  2, ( 2,  6), transform=colTransf, section=colSec, shear=0)
    model.element(column,  3, ( 3,  7), transform=colTransf, section=colSec, shear=0)
    model.element(column,  4, ( 4,  8), transform=colTransf, section=colSec, shear=0)

    model.element(column,  5, ( 5, 10), transform=colTransf, section=colSec, shear=0)
    model.element(column,  6, ( 6, 11), transform=colTransf, section=colSec, shear=0)
    model.element(column,  7, ( 7, 12), transform=colTransf, section=colSec, shear=0)
    model.element(column,  8, ( 8, 13), transform=colTransf, section=colSec, shear=0)

    model.element(column,  9, (10, 15), transform=colTransf, section=colSec, shear=0)
    model.element(column, 10, (11, 16), transform=colTransf, section=colSec, shear=0)
    model.element(column, 11, (12, 17), transform=colTransf, section=colSec, shear=0)
    model.element(column, 12, (13, 18), transform=colTransf, section=colSec, shear=0)

    # Define beam elements
    # --------------------

    # Geometric transformation for beams
    beamTransf = 2
    model.geomTransf("Linear", beamTransf, 1.0, 1.0, 0.0)

    if girder == "forceBeamColumn":
        warnings.warn("warning: forceBeamColumn specified for girder but section type is elastic.")

    # Create the beam elements
    #                   tag (ndI ndJ) transfTag integrationTag
    model.element(girder, 13, ( 5,  6), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 14, ( 6,  7), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 15, ( 7,  8), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 16, ( 8,  5), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 17, (10, 11), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 18, (11, 12), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 19, (12, 13), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 20, (13, 10), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 21, (15, 16), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 22, (16, 17), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 23, (17, 18), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 24, (18, 15), transform=beamTransf, section=beamSec, shear=0)

    # Define gravity loads
    # --------------------
    # Gravity load applied at each corner node
    # 10% of column capacity
    p = 0.1*fc*h_col*h_col

    # Mass lumped at retained nodes
    m = (4.0*p)/units.gravity

    # Set mass at the nodes
    #         tag   MX MY MZ   RX   RY   RZ
    model.mass( 5, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 6, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 7, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 8, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))

    model.mass( 10, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 11, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 12, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 13, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))

    model.mass( 15, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 16, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 17, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 18, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    # Define gravity loads
    # create a Plain load pattern with Constant scaling
    model.pattern("Plain", 1, "Constant")

    for i in [5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18]:
        model.load(i, (0.0, 0.0, -p, 0.0, 0.0, 0.0), pattern=1)

    # set rayleigh damping factors
    model.rayleigh(0.0319, 0.0, 0.0125, 0.0)

    return model

def create_bridge_model1(elastic: bool = True, girder: str = "elasticBeamColumn"):

    if girder != "elasticBeamColumn":
        raise ValueError("Only elasticBeamColumn allowed for girders.")
    
    model = xara.Model(ndm=3, ndf=6)


    # Nodes: (tag, (x, y, z))
    model.node(0, (0.0,                                  0.0,                  320.0))
    model.node(1, (3180.0,                               0.0,                  320.0))
    model.node(2, (1752.0,                               0.0,                  320.0))
    model.node(3, (1641.4628263430573,    199.41297159396336,                  320.0))
    model.node(4, (1641.4628263430573,    199.41297159396336,                    0.0))
    model.node(5, (1862.5371736569432,   -199.41297159396336,                  320.0))
    model.node(6, (1862.5371736569432,   -199.41297159396336,                    0.0))

    # Boundary conditions, fully fixed at 0, 1, 4, 6
    # fix(tag, (DX, DY, DZ, RX, RY, RZ))
    model.fix(0, (1, 1, 1, 1, 1, 1))
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))
    model.fix(6, (1, 1, 1, 1, 1, 1))

    # Materials: concrete and steel

    # Concrete strengths (ksi)
    fc_unconf = 4.0   # unconfined concrete
    fc_conf   = 5.0  # confined concrete

    # Concrete modulus (ksi), same formula as your frame model
    Ec = 57000.0 * math.sqrt(fc_unconf * 1000.0) / 1000.0

    # Steel properties
    fy = 60.0   # ksi
    Es = 30000.0

    if not elastic:
        # Nonlinear concrete (core and cover) using Concrete01
        #                    tag  f'c       epsc0         f'cu   epscu
        model.uniaxialMaterial("Concrete01", 1, -fc_conf,   -2*fc_conf/Ec,  -3.5,  -0.02)
        model.uniaxialMaterial("Concrete01", 2, -fc_unconf, -2*fc_unconf/Ec, 0.0,  -0.006)

        # Nonlinear reinforcing steel
        #                    tag fy   E0   b
        model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)
    else:
        # Elastic concrete for both core and cover
        model.uniaxialMaterial("Elastic", 1, Ec)
        model.uniaxialMaterial("Elastic", 2, Ec)

        # Elastic steel
        model.uniaxialMaterial("Elastic", 3, Es)

    
    # Section properties: 5 ft circular section
    # Geometry of circular section
    D_total = 60 #60.0        # total diameter in inches (5 ft)
    cover   = 2.0         # concrete cover in inches
    R_ext   = D_total / 2.0
    R_core  = R_ext - cover  # approximate core radius

    # mesh subdivisions for nonlinear fiber section
    numSubdivCirc = 32
    numSubdivRad  = 5
    divs = (numSubdivCirc, numSubdivRad)

    # tags
    
    colSec_fiber   = 1
    beamSec_elastic = 2   # beams stay elastic

    # ELASTIC SECTION (for elasticBeamColumn model)
    A_el = math.pi * R_ext**2
    I_el = math.pi * R_ext**4 / 4.0
    J_el = math.pi * R_ext**4 / 2.0
    nu = 0.2
    Gc = Ec / (2*(1+nu))
    GJ   = Gc * J_el
    
    model.section("Fiber", colSec_fiber, "-GJ", GJ)
    itg_col = 1
    npts_col = 4
    model.beamIntegration("Lobatto", itg_col, colSec_fiber, npts_col)

    numSubdivCirc, numSubdivRad = divs

    # core concrete
    model.patch("circ",
                1,                      # matTag = 1
                numSubdivCirc, numSubdivRad,
                0.0, 0.0,               # yCenter, zCenter
                0.0, R_core,            # intRad, extRad
                0.0, 2 * math.pi)

    # cover concrete
    model.patch("circ",
                2,                      # matTag = 2
                numSubdivCirc, numSubdivRad,
                0.0, 0.0,
                R_core, R_ext,
                0.0, 2 * math.pi)

    # longitudinal steel
    numBars = 36 # 36
    barArea = 1.56 #1.56                    # #11 bar area
    model.layer("circ",
                3,                    # steel matTag
                numBars, barArea,
                0.0, 0.0,            # yCenter, zCenter
                R_core,              # radius
                0.0, 2 * math.pi)
   

    beam_stiff_factor = 5.0
    A_beam = 864.0          # 24in × 36in = 864 in^2
    I_beam = 9.33e4 * beam_stiff_factor        # in^4  (strong axis)
    J_beam = 3.73e5 * beam_stiff_factor        # in^4  approximate torsion

    model.section("Elastic", beamSec_elastic, Ec, A_beam, I_beam, I_beam, Gc, J_beam)

    # Transformations and elements
    colTransf  = 1
    beamTransf = 2
    model.geomTransf("Linear", colTransf,  (1.0, 0.0, 0.0))
    model.geomTransf("Linear", beamTransf, 0.0, 0.0, 1.0)

    # columns: elastic vs nonlinear
    
    # columns as elasticBeamColumn with elastic section
    col_type = "forceBeamColumn"
    sec_col  = colSec_fiber

    model.element(col_type, 2, (4, 3), transform=colTransf, section=sec_col, shear=0)
    model.element(col_type, 3, (6, 5), transform=colTransf, section=sec_col, shear=0)
    

    # beams always elastic
    beam_type = "elasticBeamColumn"
    sec_beam  = beamSec_elastic

    model.element(beam_type, 1, (0, 2), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 4, (2, 1), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 5, (3, 2), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 6, (5, 2), transform=beamTransf, section=sec_beam, shear=0)


    # ---------- Gravity load and mass: template style ----------

    
    
    A_col     = math.pi * (D_total/2.0)**2 

    #  fc * A
    P_col_cap = fc_conf * A_col   #  kips

    # 10% 
    P_grav_total = 0.05 * P_col_cap         # kips
    P_per_col    = P_grav_total / 2.0      # kips

    # 
    g = units.gravity   # in/s^2
    m_per_node = P_per_col / g             # kip / (in/s^2) 

    # 
    for nd in [2, 3, 5]:
        # mass(MX, MY, MZ, RX, RY, RZ)
        model.mass(nd, (m_per_node/90, m_per_node/90, m_per_node/10, 0.0, 0.0, 0.0)) #909010

    # Plain + Constant
    model.pattern("Plain", 1, "Constant")
    for nd in [2, 3, 5]:
        model.load(nd, (0.0, 0.0, -P_per_col/2.0, 0.0, 0.0, 0.0), pattern=1)


    # rayleigh(alphaM, betaK, betaKinit, betaKcomm)
    model.rayleigh(0.0319, 0.0, 0.0125, 0.0)

    return model


def create_bridge_model(elastic: bool = True, girder: str = "elasticBeamColumn"):
    
    # #input check
    # if np.all(inputx is None) or np.all(inputy is None) or dt is None:
    #     raise ValueError("Missing inputx, inputy, or dt. Exiting.")

    # if girder != "elasticBeamColumn":
    #     raise ValueError("Only elasticBeamColumn allowed for girders.")
    
    model = xara.Model(ndm=3, ndf=6)

    if not hasattr(model, "meta") or not isinstance(model.meta, dict):
        model.meta = {}
    model.meta["column_elems"] = []

    # # Nodes: (tag, (x, y, z))
    # model.node(0, (0.0,                                  0.0,                  320.0)) # abutment 1
    # model.node(1, (3180.0,                               0.0,                  320.0)) # abutment 2
    # model.node(2, (1752.0,                               0.0,                  320.0)) # mid-deck
    # model.node(3, (1641.4628263430573,    199.41297159396336,                  320.0)) # top of column 1
    # model.node(4, (1641.4628263430573,    199.41297159396336,                    0.0)) # bottom of column 1
    # model.node(5, (1862.5371736569432,   -199.41297159396336,                  320.0)) # top of column 2
    # model.node(6, (1862.5371736569432,   -199.41297159396336,                    0.0)) # bottom of column 2

    # model.node(7, (1641.4628263430573, 0.0, 320.0))  # centerline node under col top 3
    # model.node(8, (1862.5371736569432, 0.0, 320.0))  # centerline node under col top 5

    # model.node(9, (54, 0.0, 320.0))  
    # model.node(10, (3102, 0.0, 320.0))

    y_off = 199.41297159396336

    # keep original centerline abutment nodes if you want, but DO NOT connect deck to them
    model.node(0, (0.0,    0.0, 320.0))
    model.node(1, (3180.0, 0.0, 320.0))

    # mid-deck centerline node (optional output only, not connected in scheme A unless you add it)
    # model.node(2, (1752.0, 0.0, 320.0))

    # column top/bottom
    model.node(3, (1641.4628263430573,  y_off, 320.0))  # top col 1 (+y)
    model.node(4, (1641.4628263430573,  y_off,   0.0))  # bot col 1
    model.node(5, (1862.5371736569432, -y_off, 320.0))  # top col 2 (-y)
    model.node(6, (1862.5371736569432, -y_off,   0.0))  # bot col 2

    # girder abutment nodes on two lines (scheme A)
    model.node(11, (0.0,    y_off, 320.0))   # left, +y girder
    model.node(12, (0.0,   -y_off, 320.0))   # left, -y girder
    model.node(13, (3180.0, y_off, 320.0))   # right, +y girder
    model.node(14, (3180.0,-y_off, 320.0))   # right, -y girder  

    # Boundary conditions, fully fixed at 0, 1, 4, 6
    # fix(tag, (DX, DY, DZ, RX, RY, RZ))
    model.fix(0, (1, 1, 1, 1, 1, 1))
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))
    model.fix(6, (1, 1, 1, 1, 1, 1))

    model.fix(11, (1, 1, 1, 1, 1, 1))
    model.fix(12, (1, 1, 1, 1, 1, 1))
    model.fix(13, (1, 1, 1, 1, 1, 1))
    model.fix(14, (1, 1, 1, 1, 1, 1))

    # model.fix(11, (1, 1, 1, 0, 0, 0))
    # model.fix(12, (0, 1, 1, 0, 0, 0))
    # model.fix(13, (0, 1, 1, 0, 0, 0))
    # model.fix(14, (0, 0, 1, 0, 0, 0))

    # Materials: concrete and steel

    # Concrete strengths (ksi)
    fc_unconf = 4.0   # unconfined concrete
    fc_conf   = 5.0  # confined concrete

    # Concrete modulus (ksi), same formula as your frame model
    Ec = 57000.0 * math.sqrt(fc_unconf * 1000.0) / 1000.0

    # Steel properties
    fy = 60.0   # ksi
    Es = 30000.0

    if not elastic:
        # Nonlinear concrete (core and cover) using Concrete01
        #                    tag  f'c       epsc0         f'cu   epscu
        model.uniaxialMaterial("Concrete01", 1, -fc_conf,   -2*fc_conf/Ec,  -3.5,  -0.02)
        model.uniaxialMaterial("Concrete01", 2, -fc_unconf, -2*fc_unconf/Ec, 0.0,  -0.006)

        # Nonlinear reinforcing steel
        #                    tag fy   E0   b
        model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)
    else:
        # Elastic concrete for both core and cover
        model.uniaxialMaterial("Elastic", 1, Ec)
        model.uniaxialMaterial("Elastic", 2, Ec)

        # Elastic steel
        model.uniaxialMaterial("Elastic", 3, Es)

    
    # Section properties: 5 ft circular section
    # Geometry of circular section
    D_total = 60 #60.0        # total diameter in inches (5 ft)
    cover   = 2.0         # concrete cover in inches
    R_ext   = D_total / 2.0
    R_core  = R_ext - cover  # approximate core radius

    # mesh subdivisions for nonlinear fiber section
    numSubdivCirc = 32
    numSubdivRad  = 5
    divs = (numSubdivCirc, numSubdivRad)

    # tags
    
    colSec_fiber   = 1
    beamSec_elastic = 2   # beams stay elastic

    # ELASTIC SECTION (for elasticBeamColumn model)
    A_el = math.pi * R_ext**2
    I_el = math.pi * R_ext**4 / 4.0
    J_el = math.pi * R_ext**4 / 2.0
    nu = 0.2
    Gc = Ec / (2*(1+nu))
    GJ   = Gc * J_el
    
    model.section("Fiber", colSec_fiber, "-GJ", GJ)
    itg_col = 1
    npts_col = 4
    model.beamIntegration("Lobatto", itg_col, colSec_fiber, npts_col)

    numSubdivCirc, numSubdivRad = divs

    # core concrete
    model.patch("circ",
                1,                      # matTag = 1
                numSubdivCirc, numSubdivRad,
                0.0, 0.0,               # yCenter, zCenter
                0.0, R_core,            # intRad, extRad
                0.0, 2 * math.pi)

    # cover concrete
    model.patch("circ",
                2,                      # matTag = 2
                numSubdivCirc, numSubdivRad,
                0.0, 0.0,
                R_core, R_ext,
                0.0, 2 * math.pi)

    # longitudinal steel
    numBars = 36 # 36
    barArea = 1.56 #1.56                    # #11 bar area
    model.layer("circ",
                3,                    # steel matTag
                numBars, barArea,
                0.0, 0.0,            # yCenter, zCenter
                R_core,              # radius
                0.0, 2 * math.pi)
   

    beam_stiff_factor = 24.0
    # A_beam = 864.0          # 24in × 36in = 864 in^2
    # I_beam = 9.33e4 * beam_stiff_factor        # in^4  (strong axis)
    # J_beam = 3.73e5 * beam_stiff_factor        # in^4  approximate torsion

    A_beam = 1600.0          # 40in × 40in = 1600 in^2
    I_beam = 2.13e5 * beam_stiff_factor        # in^4  (strong axis)
    J_beam = 3.60e5 * beam_stiff_factor        # in^4  approximate torsion

    model.section("Elastic", beamSec_elastic, Ec, A_beam, I_beam, I_beam, Gc, J_beam)

    

    # Transformations and elements
    colTransf  = 1
    beamTransf = 2
    model.geomTransf("Linear", colTransf,  (1.0, 0.0, 0.0))
    model.geomTransf("Linear", beamTransf, 0.0, 0.0, 1.0)

    # columns: elastic vs nonlinear
    
    # columns as elasticBeamColumn with elastic section
    col_type = "forceBeamColumn"
    sec_col  = colSec_fiber

    model.element(col_type, 2, (4, 3), transform=colTransf, section=sec_col, shear=0)
    model.element(col_type, 3, (6, 5), transform=colTransf, section=sec_col, shear=0)
    

    model.meta["column_elems"] = [2, 3]

    # beams always elastic
    beam_type = "elasticBeamColumn"
    sec_beam  = beamSec_elastic

    # replace your deck elements (0-2 and 2-1) with these
    # model.element(beam_type, 101, (0, 9), transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 102, (9, 7),  transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 103, (7, 2),  transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 104, (2, 8),  transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 105, (8, 10), transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 106, (10, 1), transform=beamTransf, section=sec_beam, shear=0)

    # model.element(beam_type, 1, (0, 2), transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 4, (2, 1), transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 5, (3, 2), transform=beamTransf, section=sec_beam, shear=0)
    # model.element(beam_type, 6, (5, 2), transform=beamTransf, section=sec_beam, shear=0)

    # model.rigidLink("beam", 7, 3)  # master=7 (centerline), slave=3 (col top)
    # model.rigidLink("beam", 8, 5)

    # +y girder: 11 -- 3 -- 13
    model.element(beam_type, 201, (11, 3), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 202, (3, 13), transform=beamTransf, section=sec_beam, shear=0)

    # -y girder: 12 -- 5 -- 14
    model.element(beam_type, 203, (12, 5), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 204, (5, 14), transform=beamTransf, section=sec_beam, shear=0)

    # diaphragms / cross-beams tying the two girders together
    model.element(beam_type, 301, (11, 12), transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 302, (3,  5),  transform=beamTransf, section=sec_beam, shear=0)
    model.element(beam_type, 303, (13, 14), transform=beamTransf, section=sec_beam, shear=0)


    # Mass, damping and earthquake excitation
    # lump_mass = 1.0  # placeholder
    # for nd in [2, 3, 5]:
    #     # mass(tag, (MX, MY, MZ, RX, RY, RZ))
    #     model.mass(nd, (lump_mass, lump_mass, 0.0, 0.0, 0.0, 0.0))

    # ---------- Gravity load and mass: template style ----------
    output_nodes = [3,5]
    print('pre-gravity disp')
    for node in output_nodes:
        print(node, model.nodeDisp(node))
    
    
    A_col     = math.pi * (D_total/2.0)**2 

    #  fc * A
    P_col_cap = fc_conf * A_col   #  kips

    # 10% 
    P_grav_total = 0.05 * P_col_cap         # kips
    P_per_col    = P_grav_total / 2.0      # kips

    # 
    g = units.gravity   # in/s^2
    m_per_node = P_per_col / g             # kip / (in/s^2) 

    # 
    for nd in [3, 5]:
        # mass(MX, MY, MZ, RX, RY, RZ)
        model.mass(nd, (m_per_node/5, m_per_node/5, m_per_node/5, 0.0, 0.0, 0.0)) #909010

    # Plain + Constant
    model.pattern("Plain", 1, "Constant")
    # for nd in [2, 3, 5]:
    #     model.load(nd, (0.0, 0.0, -P_per_col/2.0, 0.0, 0.0, 0.0), pattern=1)

    for nd in [3, 5]:
        model.load(nd, (0,0,-P_grav_total,0,0,0), pattern=1)


    print("post-gravity")
    for n in output_nodes:
        print(n, model.nodeDisp(n))

    # rayleigh(alphaM, betaK, betaKinit, betaKcomm)
    model.rayleigh(0.0319, 0.0, 0.0125, 0.0)

    # # Ground motion: fault normal (x) and fault parallel (y) components
    # # Time series for the two components
    # model.timeSeries("Path", 2, values=inputx.tolist(), dt=dt, factor=1.0)
    # model.timeSeries("Path", 3, values=inputy.tolist(), dt=dt, factor=1.0)

    # # Uniform excitation patterns in global X and Y directions
    # # pattern("UniformExcitation", tag, dof, accel=seriesTag)
    # model.pattern("UniformExcitation", 2, 1, accel=2)   # dof 1 = global X
    # model.pattern("UniformExcitation", 3, 2, accel=3)   # dof 2 = global Y

    return model

