#import opensees.openseespy as ops
import xara

#import openseespy.opensees as ops
import xara.units.iks as units
import math

#——————new import——————
from pathlib import Path
import quakeio
import numpy as np
from mdof.utilities.config import extract_channels
import csv
import os
import matplotlib.pyplot as plt
from mdof.simulate import simulate
from mdof import sysid
from mdof.validation import stabilize_discrete
from mdof.utilities.config import Config

from mdof.utilities.testing import intensity_bounds, truncate_by_bounds

import cvxpy as cp 
import dccp

import pickle
import tqdm

import warnings

LOAD_EVENTS = False

def ReinforcedRectangle(model, id, h, b, cover, coreID, coverID, steelID, numBars, barArea, nfCoreY, nfCoreZ, nfCoverY, nfCoverZ, GJ):
    r"""
    Define a procedure which generates a rectangular reinforced concrete section
    with one layer of steel evenly distributed around the perimeter and a confined core.

                          y
                          |
                          |
                          |
                ---------------------
                |\                 /|
                | \---------------/ |
                | |               | |
                | |               | |
     z ---------| |               | |  h
                | |               | |
                | |               | |
                | /---------------\ |
                |/                 \|
                ---------------------
                          b

    Arguments
       id - tag for the section that is generated by this procedure
       h - overall height of the section (see above)
       b - overall width of the section (see above)
       cover - thickness of the cover patches
       coreID - material tag for the core patch
       coverID - material tag for the cover patches
       steelID - material tag for the reinforcing steel
       numBars - number of reinforcing bars on any given side of the section
       barArea - cross-sectional area of each reinforcing bar
       nfCoreY - number of fibers in the core patch in the y direction
       nfCoreZ - number of fibers in the core patch in the z direction
       nfCoverY - number of fibers in the cover patches with long sides in the y direction
       nfCoverZ - number of fibers in the cover patches with long sides in the z direction

    Notes
       The thickness of cover concrete is constant on all sides of the core.
       The number of bars is the same on any given side of the section.
       The reinforcing bars are all the same size.
       The number of fibers in the short direction of the cover patches is set to 1.

    Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
    Date: June 2017
    """

    # The distance from the section z-axis to the edge of the cover concrete
    # in the positive y direction
    coverY = h/2.0

    # The distance from the section y-axis to the edge of the cover concrete
    # in the positive z direction
    coverZ = b/2.0

    # Determine the corresponding values from the respective axes to the
    # edge of the core concrete
    coreY = coverY - cover
    coreZ = coverZ - cover

    # Define the fiber section
    model.section("Fiber", id, GJ=GJ)

    # Define the core patch
    model.patch("quad", coreID, nfCoreZ, nfCoreY, -coreY, coreZ, -coreY, -coreZ, coreY, -coreZ, coreY, coreZ)

    # Define the four cover patches
    model.patch("quad", coverID, 1,        nfCoverY, -coverY,  coverZ, -coreY,   coreZ,   coreY,   coreZ,   coverY,  coverZ)
    model.patch("quad", coverID, 1,        nfCoverY, -coreY,  -coreZ,  -coverY, -coverZ,  coverY, -coverZ,  coreY,  -coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,        -coverY,  coverZ, -coverY, -coverZ, -coreY,  -coreZ,  -coreY,   coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,         coreY,   coreZ,   coreY,  -coreZ,   coverY, -coverZ,  coverY,  coverZ)

    # Define the steel along constant values of y (in the z direction)
    model.layer("straight", steelID, numBars, barArea, -coreY, coreZ, -coreY, -coreZ)
    model.layer("straight", steelID, numBars, barArea,  coreY, coreZ,  coreY, -coreZ)

    # Determine the spacing for the remaining bars in the y direction
    spacingY = (2.0*coreY)/(numBars-1)

    # Avoid double counting bars
    numBars = numBars-2

    # Define remaining steel in the y direction
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY,  coreZ, (-coreY+spacingY),  coreZ)
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY, -coreZ, (-coreY+spacingY), -coreZ)



def create_model(column=None, girder="elasticBeamColumn", inputx=None, inputy=None, dt=None):
    if np.all(inputx is None) or np.all(inputy is None) or dt is None:
        raise ValueError("Missing inputx, inputy, or dt. Exiting.")

    if column is None:
        column = "forceBeamColumn"

    # create Model in three-dimensions with 6 DOF/node
    model = xara.Model(ndm=3, ndf=6)

    # Geometry
    # ---------------

    # Set parameters for model geometry
    h  = 144.0;      # Story height
    by = 240.0;      # Bay width in Y-direction
    bx = 240.0;      # Bay width in X-direction

    # Create nodes
    #            tag    X        Y       Z 
    model.node( 1, (-bx/2.0,  by/2.0,   0.0))
    model.node( 2, ( bx/2.0,  by/2.0,   0.0))
    model.node( 3, ( bx/2.0, -by/2.0,   0.0))
    model.node( 4, (-bx/2.0, -by/2.0,   0.0))

    model.node( 5, (-bx/2.0,  by/2.0,     h))
    model.node( 6, ( bx/2.0,  by/2.0,     h))
    model.node( 7, ( bx/2.0, -by/2.0,     h))
    model.node( 8, (-bx/2.0, -by/2.0,     h))

    model.node(10, (-bx/2.0,  by/2.0, 2.0*h))
    model.node(11, ( bx/2.0,  by/2.0, 2.0*h))
    model.node(12, ( bx/2.0, -by/2.0, 2.0*h))
    model.node(13, (-bx/2.0, -by/2.0, 2.0*h))

    model.node(15, (-bx/2.0,  by/2.0, 3.0*h))
    model.node(16, ( bx/2.0,  by/2.0, 3.0*h))
    model.node(17, ( bx/2.0, -by/2.0, 3.0*h))
    model.node(18, (-bx/2.0, -by/2.0, 3.0*h))

    # Retained nodes for rigid diaphragm
    #        tag    ( X    Y    Z   )
    model.node( 9,  (0.0, 0.0,     h))
    model.node(14,  (0.0, 0.0, 2.0*h))
    model.node(19,  (0.0, 0.0, 3.0*h))

    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(2, (1, 1, 1, 1, 1, 1))
    model.fix(3, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))

    # Define rigid diaphragm multi-point constraints
    #              normalDir retained constrained
    model.rigidDiaphragm(3,  9,  5,  6,  7,  8)
    model.rigidDiaphragm(3, 14, 10, 11, 12, 13)
    model.rigidDiaphragm(3, 19, 15, 16, 17, 18)

    # Constraints for rigid diaphragm retained nodes
    #        tag  (DX DY DZ RX RY RZ)
    model.fix( 9, ( 0, 0, 1, 1, 1, 0))
    model.fix(14, ( 0, 0, 1, 1, 1, 0))
    model.fix(19, ( 0, 0, 1, 1, 1, 0))

    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 6.0
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0

    # Core concrete (confined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 1, -5.0, -0.005, -3.5, -0.02)

    # Cover concrete (unconfined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 2, -fc, -0.002, 0.0, -0.006)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    #                                tag fy  E0  b
    model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)

    # Column parameters
    h_col  = 18.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    # Call the RCsection procedure to generate the column section
    #                              id    h     b  cover coreid coverid steelid nBars barArea nfCoreY nfCoreZ nfCoverY nfCoverZ GJ
    ReinforcedRectangle(model, colSec, h_col, h_col, 2.5, 1,    2,    3,    3,   0.79,     8,      8,      10,      10,   GJ)

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # "Cracked" second moments of area
    Ibeamzz = 0.5*1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 0.5*1.0/12.0*24.0*pow(18.0,3)

    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, GJ, 1.0)

    # Define column elements
    # ----------------------
    # Geometric transformation for columns
    colTransf = 1
    model.geomTransf("Linear", colTransf, (1.0, 0.0, 0.0))

    # Number of column integration points (sections)
    itg_col = 1
    npts_col = 4
    model.beamIntegration("Lobatto", itg_col, colSec, npts_col)


    #                   tag ndI ndJ transfTag integrationTag
    model.element(column,  1, ( 1,  5), transform=colTransf, section=colSec, shear=0)
    model.element(column,  2, ( 2,  6), transform=colTransf, section=colSec, shear=0)
    model.element(column,  3, ( 3,  7), transform=colTransf, section=colSec, shear=0)
    model.element(column,  4, ( 4,  8), transform=colTransf, section=colSec, shear=0)

    model.element(column,  5, ( 5, 10), transform=colTransf, section=colSec, shear=0)
    model.element(column,  6, ( 6, 11), transform=colTransf, section=colSec, shear=0)
    model.element(column,  7, ( 7, 12), transform=colTransf, section=colSec, shear=0)
    model.element(column,  8, ( 8, 13), transform=colTransf, section=colSec, shear=0)

    model.element(column,  9, (10, 15), transform=colTransf, section=colSec, shear=0)
    model.element(column, 10, (11, 16), transform=colTransf, section=colSec, shear=0)
    model.element(column, 11, (12, 17), transform=colTransf, section=colSec, shear=0)
    model.element(column, 12, (13, 18), transform=colTransf, section=colSec, shear=0)

    # Define beam elements
    # --------------------
    # Geometric transformation for beams
    beamTransf = 2
    model.geomTransf("Linear", beamTransf, 1.0, 1.0, 0.0)


    # Create the beam elements
    #                   tag (ndI ndJ) transfTag integrationTag
    model.element(girder, 13, ( 5,  6), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 14, ( 6,  7), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 15, ( 7,  8), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 16, ( 8,  5), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 17, (10, 11), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 18, (11, 12), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 19, (12, 13), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 20, (13, 10), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 21, (15, 16), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 22, (16, 17), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 23, (17, 18), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 24, (18, 15), transform=beamTransf, section=beamSec, shear=0)

    # Define gravity loads
    # --------------------
    # Gravity load applied at each corner node
    # 10% of column capacity
    p = 0.1*fc*h*h

    # Mass lumped at retained nodes
    m = (4.0*p)/units.gravity

    # Rotary inertia of floor about retained node
    i = m*(bx*bx + by*by)/12.0

    # Set mass at the retained nodes
    #         tag   MX MY MZ   RX   RY   RZ
    model.mass( 9, (m, m, 0.0, 0.0, 0.0, i))
    model.mass(14, (m, m, 0.0, 0.0, 0.0, i))
    model.mass(19, (m, m, 0.0, 0.0, 0.0, i))

    # Define gravity loads
    # create a Plain load pattern with Constant scaling
    model.pattern("Plain", 1, "Constant")

    for i in [5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18]:
        model.load(i, (0.0, 0.0, -p, 0.0, 0.0, 0.0), pattern=1)

    # set rayleigh damping factors
    model.rayleigh(0.0, 0.0, 0.0, 0.0018)

    # Define earthquake excitation
    # ----------------------------
    # Set up the acceleration records for fault normal (x, dof 1) and fault parallel (y, dof 2)
    model.timeSeries("Path", 2, values=inputx.tolist(), dt=dt, factor=1.0)
    model.timeSeries("Path", 3, values=inputy.tolist(), dt=dt, factor=1.0)

    # Define the excitation using the given ground motion records
    #                         tag dir         accel series args
    model.pattern("UniformExcitation", 2, 1, accel=2)
    model.pattern("UniformExcitation", 3, 2, accel=3)

    return model

def J_rect(b, h):
    b, h = float(b), float(h)
    if b > h:
        b, h = h, b
    return b * h**3 * (1/3 - 0.21*b/h * (1 - b**4/(12*h**4)))

def cosine_taper(arr, dt, T_ramp=0.4):
    arr = np.asarray(arr, dtype=float).copy()
    n = max(1, int(T_ramp / dt))
    w = 0.5 * (1 - np.cos(np.linspace(0, np.pi, n)))
    arr[:n] *= w
    return arr


def create_frame_model(elastic: bool, girder="elasticBeamColumn", inputx=None, inputy=None, dt=None):
    if np.all(inputx is None) or np.all(inputy is None) or dt is None:
        raise ValueError("Missing inputx, inputy, or dt. Exiting.")
    
    if girder != "elasticBeamColumn":
        raise ValueError("Only elasticBeamColumn allowed for girders")

    column = "forceBeamColumn"

    # create Model in three-dimensions with 6 DOF/node
    model = xara.Model(ndm=3, ndf=6)


    # If model.meta is already a dictionary, use it directly
    if not hasattr(model, "meta") or not isinstance(model.meta, dict):
        model.meta = {}

    model.meta["column_elems"] = []

    # Geometry and Material Properties
        # Nodes(location)
        # Boundary conditions(nodes)
        # Elements(nodes, material properties,                             geometric transformation)
                          # non-fiber section elastic (linear)              # linear
                          # fiber section (linear elastic OR inelastic)     # PDelta
                                                                            # corotational

    # Geometry
    # ---------------

    # Set parameters for model geometry
    h  = 144.0;      # Story height
    by = 240.0;      # Bay width in Y-direction
    bx = 240.0;      # Bay width in X-direction

    # Create nodes
    #            tag    X        Y       Z 
    model.node( 1, (-bx/2.0,  by/2.0,   0.0))
    model.node( 2, ( bx/2.0,  by/2.0,   0.0))
    model.node( 3, ( bx/2.0, -by/2.0,   0.0))
    model.node( 4, (-bx/2.0, -by/2.0,   0.0))

    model.node( 5, (-bx/2.0,  by/2.0,     h))
    model.node( 6, ( bx/2.0,  by/2.0,     h))
    model.node( 7, ( bx/2.0, -by/2.0,     h))
    model.node( 8, (-bx/2.0, -by/2.0,     h))

    model.node(10, (-bx/2.0,  by/2.0, 2.0*h))
    model.node(11, ( bx/2.0,  by/2.0, 2.0*h))
    model.node(12, ( bx/2.0, -by/2.0, 2.0*h))
    model.node(13, (-bx/2.0, -by/2.0, 2.0*h))

    model.node(15, (-bx/2.0,  by/2.0, 3.0*h))
    model.node(16, ( bx/2.0,  by/2.0, 3.0*h))
    model.node(17, ( bx/2.0, -by/2.0, 3.0*h))
    model.node(18, (-bx/2.0, -by/2.0, 3.0*h))


    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, (1, 1, 1, 1, 1, 1))
    model.fix(2, (1, 1, 1, 1, 1, 1))
    model.fix(3, (1, 1, 1, 1, 1, 1))
    model.fix(4, (1, 1, 1, 1, 1, 1))


    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 4.0
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0
    if not elastic:
        # Core concrete (confined)
        #                                 tag  f'c   epsc0  f'cu  epscu
        model.uniaxialMaterial("Concrete01", 1, -5.0, -0.005, -3.5, -0.02)
        # Cover concrete (unconfined)
        #                                 tag  f'c   epsc0  f'cu  epscu
        model.uniaxialMaterial("Concrete01", 2, -fc, -0.002, 0.0, -0.006)
    else:
        # Core concrete
        model.uniaxialMaterial("Elastic", 1, Ec)
        # Cover concrete
        model.uniaxialMaterial("Elastic", 2, Ec)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    if not elastic:
        #                                tag fy  E0  b
        model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)
    else:
        model.uniaxialMaterial("Elastic", 3, Es)


    # Define column elements
    # ----------------------

    # Column parameters
    h_col  = 20.0
    b_col = 20.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    if True:
        # # Call the RCsection procedure to generate the column section
        ReinforcedRectangle(model, colSec,
                            h=h_col, 
                            b=b_col,
                            cover=2.5, 
                            coreID=1,
                            coverID=2,
                            steelID=3,
                            numBars=3,
                            barArea=0.79,
                            nfCoreY=8,      
                            nfCoreZ=8,      
                            nfCoverY=10,      
                            nfCoverZ=10,
                            GJ=GJ)
        # Number of column integration points (sections)
        itg_col = 1
        npts_col = 4
        model.beamIntegration("Lobatto", itg_col, colSec, npts_col)
        
    # Geometric transformation for columns
    colTransf = 1
    model.geomTransf("Linear", colTransf, (1.0, 0.0, 0.0))

    #                   tag ndI ndJ transfTag integrationTag
    model.element(column,  1, ( 1,  5), transform=colTransf, section=colSec, shear=0)
    model.element(column,  2, ( 2,  6), transform=colTransf, section=colSec, shear=0)
    model.element(column,  3, ( 3,  7), transform=colTransf, section=colSec, shear=0)
    model.element(column,  4, ( 4,  8), transform=colTransf, section=colSec, shear=0)

    model.element(column,  5, ( 5, 10), transform=colTransf, section=colSec, shear=0)
    model.element(column,  6, ( 6, 11), transform=colTransf, section=colSec, shear=0)
    model.element(column,  7, ( 7, 12), transform=colTransf, section=colSec, shear=0)
    model.element(column,  8, ( 8, 13), transform=colTransf, section=colSec, shear=0)

    model.element(column,  9, (10, 15), transform=colTransf, section=colSec, shear=0)
    model.element(column, 10, (11, 16), transform=colTransf, section=colSec, shear=0)
    model.element(column, 11, (12, 17), transform=colTransf, section=colSec, shear=0)
    model.element(column, 12, (13, 18), transform=colTransf, section=colSec, shear=0)

    
    for ele_tag in range(1, 13):
        model.meta["column_elems"].append(ele_tag)

    # Define beam elements
    # --------------------

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # Second moments of area
    Ibeamzz = 1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 1.0/12.0*24.0*pow(18.0,3)

    nu = 0.2
    Gb = Ec/(2 * (1 + nu))

    Jbeam = J_rect(18.0, 24.0)
    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, Gb, Jbeam)

    # Geometric transformation for beams
    beamTransf = 2
    model.geomTransf("Linear", beamTransf, 0.0, 0.0, 1.0)

    # Create the beam elements
    #                   tag (ndI ndJ) transfTag integrationTag
    model.element(girder, 13, ( 5,  6), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 14, ( 6,  7), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 15, ( 7,  8), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 16, ( 8,  5), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 17, (10, 11), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 18, (11, 12), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 19, (12, 13), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 20, (13, 10), transform=beamTransf, section=beamSec, shear=0)

    model.element(girder, 21, (15, 16), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 22, (16, 17), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 23, (17, 18), transform=beamTransf, section=beamSec, shear=0)
    model.element(girder, 24, (18, 15), transform=beamTransf, section=beamSec, shear=0)


    # ================== helpers (ADD THIS BLOCK) ==================
    

    # column_conn = {
    #     1:(1,5),  2:(2,6),  3:(3,7),  4:(4,8),
    #     5:(5,10), 6:(6,11), 7:(7,12), 8:(8,13),
    #     9:(10,15),10:(11,16),11:(12,17),12:(13,18)
    # }
    # model.meta["column_conn"] = column_conn
    # model.meta["column_len"]  = {ele: h for ele in model.meta["column_elems"]}  
    # model.meta["section_depth"] = float(h_col)  # Section height (for edge strain eps_edge = eps0 ± kappa*h/2）

    # # ---- elastic query: Approximate eps0, kappa ---- using end node displacement/rotation Angle
    # # Agreement: The axial direction of the column is Z (UZ), and the curvature is calculated as the difference in rotation angles at the end nodes divided by the length.
    # # Note: For vertical components, bending in the X-direction corresponds to "rotation around the Y-axis (RY)", and bending in the Y-direction corresponds to "rotation around the X-axis (RX)" (if replacement is needed, simply change the idx mapping).
    # def _query_section_eps0(ele):
    #     ni, nj = model.meta["column_conn"][ele]
    #     uzi = model.nodeDisp(ni)[2]   # UZ at i
    #     uzj = model.nodeDisp(nj)[2]   # UZ at j
    #     L   = model.meta["column_len"][ele]
    #     return (uzj - uzi) / L

    # def _query_section_kappa(ele, axis='x'):
    #     # To match the common conventions of vertical columns: 
    #     # X-direction displacement dominant → bending around the Y-axis; Y-direction displacement dominance → bending around the X-axis
    #     # Therefore, here we map axis='x' to RY and axis='y' to RX (if your local coordinates are different, you can switch them as needed).
    #     idx_map = {'x':4, 'y':3, 'z':5}  # RX=3, RY=4, RZ=5（0-based）
    #     idx = idx_map[axis]
    #     ni, nj = model.meta["column_conn"][ele]
    #     thi = model.nodeDisp(ni)[idx]
    #     thj = model.nodeDisp(nj)[idx]
    #     L   = model.meta["column_len"][ele]
    #     return (thj - thi) / L


    # # start strain_record record_strain_step
    # sr = {
    #     "enabled": True,
    #     "inelastic": bool(column == "forceBeamColumn"),
    #     "section_depth": model.meta["section_depth"],
    #     "time": [],
    #     "eps0":  {ele: [] for ele in model.meta["column_elems"]},
    #     "kappa": {ele: [] for ele in model.meta["column_elems"]},
    #     "conc_edge_max": {ele: [] for ele in model.meta["column_elems"]},
    #     "steel_max":     {ele: [] for ele in model.meta["column_elems"]},
    #     "edge_fibers": {},
    #     "steel_mats":  {},
    # }
    # if sr["inelastic"]:
    #     hsec = model.meta["section_depth"]
    #     for ele in model.meta["column_elems"]:
    #         sr["edge_fibers"][ele] = [(0, +hsec/2.0, 0.0),
    #                                   (0, -hsec/2.0, 0.0)]
    #         sr["steel_mats"][ele] = []
    # model.meta["strain_record"] = sr
    # ================== END helpers (ADD THIS BLOCK) ==================

    # Define gravity loads
    # --------------------
    # Gravity load applied at each corner node
    # 10% of column capacity
    p = 0.1*fc*b_col*h_col /4.0

    # Mass lumped at retained nodes
    m = (4.0*p)/units.gravity

    # Rotary inertia of floor about retained node
    i = m*(bx*bx + by*by)/12.0


    # Set mass at the nodes
    #         tag   MX MY MZ   RX   RY   RZ
    model.mass( 5, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 6, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 7, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 8, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))

    model.mass( 10, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 11, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 12, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 13, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))

    model.mass( 15, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 16, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 17, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    model.mass( 18, (m/4, m/4, 0.0, 0.0, 0.0, 0.0))
    # Define gravity loads
    # create a Plain load pattern with Constant scaling
    model.pattern("Plain", 1, "Constant")

    for i in [5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18]:
        model.load(i, (0.0, 0.0, -p, 0.0, 0.0, 0.0), pattern=1)

    # set rayleigh damping factors
    model.rayleigh(0.0319, 0.0, 0.0125, 0.0)

    # Define earthquake excitation
    # ----------------------------
    # Set up the acceleration records for fault normal (x, dof 1) and fault parallel (y, dof 2)
    inputx_t = cosine_taper(inputx, dt, T_ramp=0.4)
    inputy_t = cosine_taper(inputy, dt, T_ramp=0.4)
    model.timeSeries("Path", 2, values=inputx_t.tolist(), dt=dt, factor=1.0)
    model.timeSeries("Path", 3, values=inputy_t.tolist(), dt=dt, factor=1.0)
    
    # model.timeSeries("Path", 2, values=inputx.tolist(), dt=dt, factor=1.0)
    # model.timeSeries("Path", 3, values=inputy.tolist(), dt=dt, factor=1.0)

    # Define the excitation using the given ground motion records
    #                         tag dir         accel series args
    model.pattern("UniformExcitation", 2, 1, accel=2)
    model.pattern("UniformExcitation", 3, 2, accel=3)

    return model


def get_inputs(i, events, input_channels, scale=1):
    event = events[i]
    inputs, dt = extract_channels(event, input_channels)
    inputs = scale*inputs
    return inputs, dt


def save_event_io(i, inputs, outputs, dt, out_dir="event_data"):
    os.makedirs(out_dir, exist_ok=True)
    nt = inputs.shape[1]
    time = np.arange(nt) * dt
    
    # —— Save as CSV (readable) —— 
    csv_in = os.path.join(out_dir, f"event_{i+1}_inputs.csv")
    with open(csv_in, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["time","acc_X","acc_Y"])
        for t, x, y in zip(time, inputs[0], inputs[1]):
            writer.writerow([t, x, y])
    
    csv_out = os.path.join(out_dir, f"event_{i+1}_outputs.csv")
    with open(csv_out, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["time","1F_X","1F_Y","2F_X","2F_Y","3F_X","3F_Y"])
        for idx in range(nt):
            row = [time[idx]] + [outputs[r,idx] for r in range(6)]
            writer.writerow(row)


def record_strain_step(model, t):
    """
    Use it once per time rhythm
    - elasticBeamColumn: Record eps0 and kappa (then use eps_edge=eps0+kappa*h/2)
    - Nonlinearity (forceBeamColumn+fiber) : Record the "maximum strain of edge concrete fibers" and the "maximum strain of reinforcing bar fibers"
    """
    sr = getattr(model, "meta", {}).get("strain_record", None)
    if not sr or not sr.get("enabled", False):
        return

    # record time
    sr["time"].append(float(t))

    # elastic/inelastic
    if not sr.get("inelastic", False):
        # ---- elastic：eps0, kappa ----
        for ele in model.meta["column_elems"]:
            eps0  = getattr(model, "query_section_eps0",  lambda e: np.nan)(ele)
            kappa = getattr(model, "query_section_kappa", lambda e, axis='x': np.nan)(ele, axis='x')
            sr["eps0"][ele].append(float(eps0)  if eps0  is not None else np.nan)
            sr["kappa"][ele].append(float(kappa) if kappa is not None else np.nan)
        return

    # ---- Nonlinearity: take the maximum strain ---- for the edge concrete and reinforcing bars
    for ele in model.meta["column_elems"]:
        # Concrete edge fibers (±h/2,z=0)
        max_conc = None
        for (sec_idx, y, z) in sr.get("edge_fibers", {}).get(ele, []):
            val = getattr(model, "query_fiber_strain", lambda *a, **k: None)(
                ele, sec_idx=sec_idx, y=y, z=z
            )
            if val is not None:
                max_conc = val if max_conc is None else max(max_conc, val)
        sr["conc_edge_max"][ele].append(float(max_conc) if max_conc is not None else np.nan)

        # Reinforcing bar material fiber
        max_steel = None
        for (sec_idx, mat_tag) in sr.get("steel_mats", {}).get(ele, []):
            val = getattr(model, "query_material_strain", lambda *a, **k: None)(
                ele, sec_idx=sec_idx, mat_tag=mat_tag
            )
            if val is not None:
                max_steel = val if max_steel is None else max(max_steel, val)
        sr["steel_max"][ele].append(float(max_steel) if max_steel is not None else np.nan)

    
def get_material_response(model, element, sec_tag, y, z):
    try:
        strain =  model.eleResponse(element, "section", sec_tag, "fiber", y, z, "strain")
        stress =  model.eleResponse(element, "section", sec_tag, "fiber", y, z, "stress")
        return stress, strain
    except Exception as e:
        print(e)
        return None


def analyze(model, output_nodes, nt, dt, n_modes=3,
            output_elements=[1,5,9],
            yFiber=8.0,
            zFiber=0.0):

    if not hasattr(analyze, "call_count"):
        analyze.call_count = 0

    analyze.call_count += 1
    event_id = analyze.call_count

    # ----------------------------
    # 1. Configure the analysis
    # ----------------------------

    # create the system of equation
    model.system("BandGen")

    # create the DOF numberer
    model.numberer("RCM")

    # create the constraint handler
    model.constraints("Transformation")

    # Configure the analysis such that iterations are performed until either:
    # 1. the energy increment is less than 1.0e-14 (success)
    # 2. the number of iterations surpasses 20 (failure)
    #model.test("EnergyIncr", 1.0e-14, 40)
    model.test("NormDispIncr", 1.0e-6, 40)

    # Perform iterations with the Newton-Raphson algorithm
    #model.algorithm("Newton")
    model.algorithm("NewtonLineSearch")

    # define the integration scheme, the Newmark with gamma=0.5 and beta=0.25
    model.integrator("Newmark", 0.5, 0.25)

    # Define the analysis
    model.analysis("Transient")

    # -----------------------
    # 3. Perform the analysis
    # -----------------------

    # record once at time 0
    displacements = {
        node: [model.nodeDisp(node)] for node in output_nodes
    }
    strains = {
        element: [get_material_response(model, 1, 1, None, yFiber, zFiber)[1] for element in output_elements]
    }
    stresses = {
        element: [get_material_response(model, 1, 1, None, yFiber, zFiber)[0] for element in output_elements]
    }

    # get modes
    lambdas = model.eigen(n_modes) 
    omega = np.sqrt(np.abs(lambdas))
    freqs_before = omega / (2 * np.pi) 
    periods_before = 2 * np.pi / omega
    #print(omega) # TODO: instead of printing, save this in a file so we know which earthquake it belongs to

    # Perform nt analysis steps with a time step of dt
    print(f"Analysis Progress ({nt} timesteps)")
    for i in tqdm.tqdm(range(nt)):
        status = model.analyze(1, dt) 
        if status != 0:
            raise RuntimeError(f"analysis failed at time {model.getTime()}")

        # TODO: use this line to debug        
        # print(get_material_response(model, 1, 1, 0.0, 0.0))
        # import sys
        # sys.exit()

        # Save displacements at the current time
        for node in output_nodes:
            displacements[node].append(model.nodeDisp(node))
        
        for element in output_elements:
            strains[element].append(get_material_response(model, element, 1, yFiber, zFiber)[0])
            stresses[element].append(get_material_response(model, element, 1, yFiber, zFiber)[1])

    lambdas_after = model.eigen(n_modes) 
    omega_after = np.sqrt(np.abs(lambdas_after))   
    freqs_after = omega_after / (2 * np.pi)
    periods_after = 2 * np.pi / omega_after   

    csv_path = "natural_frequencies.csv" 
    file_exists = os.path.exists(csv_path)

    with open(csv_path, "a", newline="") as f:
        writer = csv.writer(f)
        if not file_exists:
            header = ["event_id"]
            header += [f"f{i+1}_before_s" for i in range(n_modes)] #Hz
            header += [f"f{i+1}_after_s" for i in range(n_modes)]
            writer.writerow(header)
        row = [event_id] + list(periods_before) + list(periods_after)
        writer.writerow(row)
           
    return displacements, stresses, strains


def get_outputs(displacements):
    """
    displacements: { node_id: [ [u1,u2,u3,u4,u5,u6], ... ] }
    Returns outputs: ndarray, shape=(6, nt), row order:
      [1F X, 1F Y, 2F X, 2F Y, 3F X, 3F Y]
    """
    floors = [5, 10, 15] #[9, 14, 19]  [5, 10, 15]
    rows = []
    for node in floors:
        arr = np.array(displacements[node])  # shape (nt+1, 6)
        rows.append(arr[:, 0])  # X displacement 
        rows.append(arr[:, 1])  # Y displacement
    outputs = np.vstack(rows)
    return outputs     # shape (6, nt+1)


def stabilize_with_lmi(A_hat, epsilon=1e-10, solver='CVXOPT'):

    """
    Only the matrix A_s obtained from algorithms such as SRIM is stabilized by imposing a Lyapunov LMI constraint to obtain a stable A. 
    The matrices B_s, C_s, and D_s are directly used as output. 
    This corresponds to Section II of Lacy & Bernstein (2003).
    The solver can be set to either SCS or CVXOPT, and epsilon can be chosen starting from 1e-8.
    """
    n = A_hat.shape[0]

    # #Define only Q and P as variables
    P = cp.Variable((n, n), PSD=True)
    Q = cp.Variable((n, n))

    # —— Objective function ——— (Equation 2.17)
    objective = cp.Minimize(cp.norm(A_hat @ P - Q, "fro")**2)

    # —— Lyapunov LMI constraint ——— (Equation 2.18)
    M = cp.bmat([
        [P - epsilon * np.eye(n), Q],
        [Q.T, P]
    ])
    constraints = [M >> 0]

    # —— Solve the optimization problem —— 
    prob = cp.Problem(objective, constraints)
    prob.solve(solver=solver)

    A_lmi = Q.value @ np.linalg.inv(P.value)
    return A_lmi


def stabilize_by_radius_clipping(A, alpha=0.995, rmin=None, make_real=True):
    w, V = np.linalg.eig(A)             
    r = np.abs(w)
    w_new = w.copy()
    over = r > 1.0
    w_new[over] = alpha * w[over] / r[over]
    if rmin is not None:
        under = np.abs(w_new) < rmin
        w_new[under] = rmin * w_new[under] / (np.abs(w_new[under]) + 1e-15)
    A_new = V @ np.diag(w_new) @ np.linalg.inv(V)
    if make_real and np.allclose(A_new.imag, 0, atol=1e-10):
        A_new = A_new.real
    return A_new


def get_true_modes_xara(model, floor_nodes=(9,14,19), dofs=(1,2), n=3, solver='-genBandArpack'): #-symmBandLapack -genBandArpack
    lambdas = model.eigen(n)  
    print(f"[Debug] eigen(n={n}) returned {len(lambdas)} values: {lambdas}")
    lambdas = np.asarray(lambdas, dtype=float)
    omega = np.sqrt(np.abs(lambdas))                    # rad/s
    freqs_hz = omega / (2*np.pi)
    rows = []
    for node in floor_nodes:
        for dof in dofs:
            rows.append([model.nodeEigenvector(node, k+1, dof) for k in range(n)])
    Phi_true = np.array(rows, dtype=float)              # (6, nmodes)
    Phi_true /= (np.linalg.norm(Phi_true, axis=0, keepdims=True) + 1e-12)
    idx = np.argsort(freqs_hz)         
    freqs_hz = freqs_hz[idx]
    Phi_true = Phi_true[:, idx]       
    return freqs_hz, Phi_true


def mac_matrix(Phi_true, Phi_est):
    print(type(Phi_est))
    print(np.shape(Phi_est))
    T = Phi_true / (np.linalg.norm(Phi_true, axis=0, keepdims=True) + 1e-12)
    E = Phi_est  / (np.linalg.norm(Phi_est,  axis=0, keepdims=True) + 1e-12)
    return np.abs(T.T @ E)**2     


def normalize_v(v):
    """
    Normalize an individual vector:
    element-wise signed complex magnitude, unitized
    i.e.:
    for each element, multiply the sign of its real part
    by the square root of the element multiplied by its
    complex conjugate.
    then, divide the vector by its Euclidean norm, or the
    square root of the sum of the elements squared.
    """
    vabs = np.abs(v)
    signed_vabs = np.sign(np.real(v)) * vabs
    normed_vabs = signed_vabs / np.linalg.norm(signed_vabs)
    return normed_vabs


def normalize_Psi(Psi):
    """
    Normalize a matrix of complex column vectors using
    `normalize_v` on each vector
    """
    normed_Psi = np.zeros(Psi.shape)
    for i in range(Psi.shape[1]):
        v = Psi[:,i]
        normed_Psi[:,i] = normalize_v(v)
    return normed_Psi


def phi_output(A, C):
    eigvals, U = np.linalg.eig(np.asarray(A, dtype=complex))
    angles = np.abs(np.angle(eigvals))
    idx = np.where(
        (np.abs(eigvals) < 1 - 1e-10) & 
        #(np.abs(eigvals) > 0.05) & 
        (np.imag(eigvals) > -1e-12)&
        (angles > 0.02)
        )[0]
    eigvals_sel = eigvals[idx]
    U_sel = U[:, idx]
    V = C @ U_sel
    Phi = normalize_Psi(V)  
    return Phi, eigvals_sel


def periods_from_A(A, dt):
    eigvals = np.linalg.eigvals(A)
    idx = np.abs(eigvals) < 1.0 
    eigvals = eigvals[idx]
    omega = np.abs(np.angle(eigvals)) / dt  # rad/s
    freqs = omega / (2 * np.pi)
    periods = 1 / freqs
    return np.sort(periods)


def save_all_methods_to_csv(i, methods_dict):
    """
    methods_dict: {'srim': (A,B,C,D), 'n4sid': (A,B,C,D), ...}
    """
    out_dir = "event_outputs_ABCD"
    os.makedirs(out_dir, exist_ok=True)
    filename = os.path.join(out_dir, f"event_modes_{i+1:02d}.csv")
    with open(filename, "w") as f:
        for method, (A, B, C, D) in methods_dict.items():
            for matrix_name, M in zip(['A','B','C','D'], [A, B, C, D]):
                f.write(f"# {method.upper()}-{matrix_name}\n")
                np.savetxt(f, M, delimiter=",", fmt="%.8e")
                f.write("\n")  # Add an empty line for readability
    print(f"Saved all system matrices for event {i+1} to {filename}")


def save_event_modes_to_csv(event_id, Phi_true, method_modes, method_macs, algos, filename):
    # method_modes: {'srim': Phi_srim, ...}  Phi, shape=(dof, n_modes)
    # method_macs:  {'srim': MAC_srim, ...}  MAC,  shape=(n_modes, n_modes)
    with open(filename, "w", newline='') as f:
        writer = csv.writer(f)
        writer.writerow([f"Event {event_id} True Mode Shapes"])
        for i in range(Phi_true.shape[1]):
            writer.writerow([f"True Mode {i+1}"] + list(Phi_true[:, i]))

        for algo in algos:
            writer.writerow([f"{algo.upper()} Mode Shapes"])
            Phi = method_modes[algo]
            for i in range(Phi.shape[1]):
                writer.writerow([f"{algo.upper()} Mode {i+1}"] + list(Phi[:, i]))

        for algo in algos:
            writer.writerow([f"{algo.upper()} MAC vs True"])
            MAC = method_macs[algo]
            for row in MAC:
                writer.writerow([""] + list(row))
        
        writer.writerow([])  


def plot_q4_max_strain(sr, model, title, html_base, PLOTLY_OK=True):
    """
    sr = model.meta["strain_record"]
    Generate the time history curve of the maximum edge concrete strain/reinforcement strain (nonlinear) or edge strain (elastic).
    """
    if not PLOTLY_OK:
        return
    import numpy as np, plotly.graph_objects as go, os

    t = np.asarray(sr["time"], float)
    cols = model.meta["column_elems"]

    if not sr.get("inelastic", False):
        # ELASTIC: eps_edge = eps0 + kappa*h/2
        h = float(sr.get("section_depth", np.nan))
        stack = []
        for ele in cols:
            eps0  = np.asarray(sr["eps0"][ele],  float)
            kappa = np.asarray(sr["kappa"][ele], float)
            edge  = eps0 + kappa * (h/2.0)
            stack.append(edge)
        edge_max = np.nanmax(np.vstack(stack), axis=0) if stack else np.full_like(t, np.nan)

        fig = go.Figure()
        fig.add_scatter(x=t, y=edge_max, mode="lines", name="Max Edge Strain (elastic)")
        fig.update_layout(title=title, xaxis_title="Time (s)", yaxis_title="Strain")
        fig.write_html(html_base + "_elastic_edge.html", include_plotlyjs="cdn")
        return

    # INELASTIC: concrete edge max & steel max
    conc_stack, steel_stack = [], []
    for ele in cols:
        conc_stack.append(np.asarray(sr["conc_edge_max"][ele], float))
        steel_stack.append(np.asarray(sr["steel_max"][ele],     float))
    conc_max  = np.nanmax(np.vstack(conc_stack),  axis=0) if conc_stack  else np.full_like(t, np.nan)
    steel_max = np.nanmax(np.vstack(steel_stack), axis=0) if steel_stack else np.full_like(t, np.nan)

    f1 = go.Figure(); f2 = go.Figure()
    f1.add_scatter(x=t, y=conc_max,  mode="lines", name="Max Concrete Edge Strain")
    f2.add_scatter(x=t, y=steel_max, mode="lines", name="Max Steel Strain")
    f1.update_layout(title=title+" — Concrete", xaxis_title="Time (s)", yaxis_title="Strain")
    f2.update_layout(title=title+" — Steel",    xaxis_title="Time (s)", yaxis_title="Strain")
    f1.write_html(html_base + "_inelastic_conc.html",  include_plotlyjs="cdn")
    f2.write_html(html_base + "_inelastic_steel.html", include_plotlyjs="cdn")


def get_natural_periods(model, nmodes=3):
    """
    Return a periodic array T (in s) of length nmodes.
    Suppose the eigen/modal interface returns the eigenvalue λ = ω^2 (OpenSees style).
    If your interface directly returns ω (rad/s), simply change the sqrt line below to not take sqrt.
    """
    import numpy as np

    evals = None
    for api in ("modal_eigenvalues", "eigenvalues", "eigen"):
        if hasattr(model, api):
            try:
                evals = getattr(model, api)(nmodes)
                break
            except Exception:
                pass
    if evals is None:
        raise RuntimeError("No modal eigenvalue API found on model (tried modal_eigenvalues/eigenvalues/eigen).")

    evals = np.asarray(evals, float)            # λ = ω^2
    omegas = np.sqrt(np.clip(evals, 0.0, None)) # ω
    T = 2*np.pi / np.where(omegas > 1e-12, omegas, np.nan)
    return T


def plot_deltaT_across_events(event_ids, dT_pct_list, plotly_dir, title="ΔT/T after EQ (Inelastic)"):
    """
    Draw the "percentage change of each event period" of the nonlinear model (by default, the first mode is taken, or any sequence you pass in).
    """
    import os
    if not event_ids or not dT_pct_list:
        return
    try:
        import plotly.graph_objects as go
    except Exception:
        return
    fig = go.Figure()
    fig.add_bar(x=[f"E{e:02d}" for e in event_ids], y=dT_pct_list, name="ΔT/T (%)")
    fig.update_layout(title=title, xaxis_title="Event", yaxis_title="Change (%)")
    os.makedirs(plotly_dir, exist_ok=True)
    outp = os.path.join(plotly_dir, "q5_dT_mode1_across_events.html")
    fig.write_html(outp, include_plotlyjs="cdn")
    print("[Q5] Saved →", outp)

